// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package persister

import (
	"context"
)

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM category WHERE id = ?
`

func (q *Queries) DeleteCategory(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCategory, id)
	return err
}

const deleteCodebase = `-- name: DeleteCodebase :exec
DELETE FROM codebase WHERE id = ?
`

func (q *Queries) DeleteCodebase(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCodebase, id)
	return err
}

const deleteCodebaseByProjectIdAndVersionTag = `-- name: DeleteCodebaseByProjectIdAndVersionTag :exec
DELETE FROM codebase WHERE project_id = ? AND version_tag = ?
`

type DeleteCodebaseByProjectIdAndVersionTagParams struct {
	ProjectID  int64
	VersionTag string
}

func (q *Queries) DeleteCodebaseByProjectIdAndVersionTag(ctx context.Context, arg DeleteCodebaseByProjectIdAndVersionTagParams) error {
	_, err := q.db.ExecContext(ctx, deleteCodebaseByProjectIdAndVersionTag, arg.ProjectID, arg.VersionTag)
	return err
}

const deleteCodebaseSurveys = `-- name: DeleteCodebaseSurveys :exec
DELETE FROM survey WHERE codebase_id = ?
`

func (q *Queries) DeleteCodebaseSurveys(ctx context.Context, codebaseID int64) error {
	_, err := q.db.ExecContext(ctx, deleteCodebaseSurveys, codebaseID)
	return err
}

const deleteFile = `-- name: DeleteFile :exec
DELETE FROM file WHERE id = ?
`

func (q *Queries) DeleteFile(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteFile, id)
	return err
}

const deleteImport = `-- name: DeleteImport :exec
DELETE FROM import WHERE id = ?
`

func (q *Queries) DeleteImport(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteImport, id)
	return err
}

const deleteMethod = `-- name: DeleteMethod :exec
DELETE FROM method WHERE id = ?
`

func (q *Queries) DeleteMethod(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMethod, id)
	return err
}

const deleteModule = `-- name: DeleteModule :exec
DELETE FROM module WHERE id = ?
`

func (q *Queries) DeleteModule(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteModule, id)
	return err
}

const deleteModuleVersion = `-- name: DeleteModuleVersion :exec
DELETE FROM module_version WHERE id = ?
`

func (q *Queries) DeleteModuleVersion(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteModuleVersion, id)
	return err
}

const deletePackage = `-- name: DeletePackage :exec
DELETE FROM package WHERE id = ?
`

func (q *Queries) DeletePackage(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deletePackage, id)
	return err
}

const deletePackageType = `-- name: DeletePackageType :exec
DELETE FROM package_type WHERE id = ?
`

func (q *Queries) DeletePackageType(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deletePackageType, id)
	return err
}

const deletePackageVersion = `-- name: DeletePackageVersion :exec
DELETE FROM package_version WHERE id = ?
`

func (q *Queries) DeletePackageVersion(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deletePackageVersion, id)
	return err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM project WHERE id = ?
`

func (q *Queries) DeleteProject(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteProject, id)
	return err
}

const deleteProjectByName = `-- name: DeleteProjectByName :exec
DELETE FROM project WHERE name = ?
`

func (q *Queries) DeleteProjectByName(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, deleteProjectByName, name)
	return err
}

const deleteSurvey = `-- name: DeleteSurvey :exec
DELETE FROM survey WHERE id = ?
`

func (q *Queries) DeleteSurvey(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSurvey, id)
	return err
}

const deleteSurveyModule = `-- name: DeleteSurveyModule :exec
DELETE FROM survey_module WHERE id = ?
`

func (q *Queries) DeleteSurveyModule(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSurveyModule, id)
	return err
}

const deleteSymbolType = `-- name: DeleteSymbolType :exec
DELETE FROM symbol_type WHERE id = ?
`

func (q *Queries) DeleteSymbolType(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSymbolType, id)
	return err
}

const deleteType = `-- name: DeleteType :exec
DELETE FROM type WHERE id = ?
`

func (q *Queries) DeleteType(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteType, id)
	return err
}

const deleteVariable = `-- name: DeleteVariable :exec
DELETE FROM variable WHERE id = ?
`

func (q *Queries) DeleteVariable(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteVariable, id)
	return err
}

const insertCategory = `-- name: InsertCategory :one
INSERT INTO category ( survey_id,name ) VALUES ( ?,? ) RETURNING id, survey_id, name
`

type InsertCategoryParams struct {
	SurveyID int64
	Name     string
}

func (q *Queries) InsertCategory(ctx context.Context, arg InsertCategoryParams) (Category, error) {
	row := q.db.QueryRowContext(ctx, insertCategory, arg.SurveyID, arg.Name)
	var i Category
	err := row.Scan(&i.ID, &i.SurveyID, &i.Name)
	return i, err
}

const insertCodebase = `-- name: InsertCodebase :one
INSERT INTO codebase ( project_id,version_tag,source_url ) VALUES ( ?,?,? ) RETURNING id, project_id, version_tag, source_url
`

type InsertCodebaseParams struct {
	ProjectID  int64
	VersionTag string
	SourceUrl  string
}

func (q *Queries) InsertCodebase(ctx context.Context, arg InsertCodebaseParams) (Codebase, error) {
	row := q.db.QueryRowContext(ctx, insertCodebase, arg.ProjectID, arg.VersionTag, arg.SourceUrl)
	var i Codebase
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.VersionTag,
		&i.SourceUrl,
	)
	return i, err
}

const insertFile = `-- name: InsertFile :one
INSERT INTO file ( survey_id,filepath ) VALUES ( ?,? ) RETURNING id, survey_id, filepath
`

type InsertFileParams struct {
	SurveyID int64
	Filepath string
}

func (q *Queries) InsertFile(ctx context.Context, arg InsertFileParams) (File, error) {
	row := q.db.QueryRowContext(ctx, insertFile, arg.SurveyID, arg.Filepath)
	var i File
	err := row.Scan(&i.ID, &i.SurveyID, &i.Filepath)
	return i, err
}

const insertImport = `-- name: InsertImport :one
INSERT INTO import ( file_id, survey_id, package_id, alias ) VALUES ( ?,?,?,? ) RETURNING id, file_id, survey_id, package_id, alias
`

type InsertImportParams struct {
	FileID    int64
	SurveyID  int64
	PackageID int64
	Alias     string
}

func (q *Queries) InsertImport(ctx context.Context, arg InsertImportParams) (Import, error) {
	row := q.db.QueryRowContext(ctx, insertImport,
		arg.FileID,
		arg.SurveyID,
		arg.PackageID,
		arg.Alias,
	)
	var i Import
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.SurveyID,
		&i.PackageID,
		&i.Alias,
	)
	return i, err
}

const insertMethod = `-- name: InsertMethod :one
INSERT INTO method ( name,params,results,type_id,file_id,survey_id ) VALUES ( ?,?,?,?,?,? ) RETURNING id, name, params, results, file_id, survey_id, type_id
`

type InsertMethodParams struct {
	Name     string
	Params   string
	Results  string
	TypeID   int64
	FileID   int64
	SurveyID int64
}

func (q *Queries) InsertMethod(ctx context.Context, arg InsertMethodParams) (Method, error) {
	row := q.db.QueryRowContext(ctx, insertMethod,
		arg.Name,
		arg.Params,
		arg.Results,
		arg.TypeID,
		arg.FileID,
		arg.SurveyID,
	)
	var i Method
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Params,
		&i.Results,
		&i.FileID,
		&i.SurveyID,
		&i.TypeID,
	)
	return i, err
}

const insertModule = `-- name: InsertModule :one
INSERT INTO module ( name ) VALUES ( ? ) RETURNING id, name
`

func (q *Queries) InsertModule(ctx context.Context, name string) (Module, error) {
	row := q.db.QueryRowContext(ctx, insertModule, name)
	var i Module
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const insertModuleVersion = `-- name: InsertModuleVersion :one
INSERT INTO module_version ( module_id, version ) VALUES ( ?,? ) RETURNING id, module_id, version
`

type InsertModuleVersionParams struct {
	ModuleID int64
	Version  string
}

func (q *Queries) InsertModuleVersion(ctx context.Context, arg InsertModuleVersionParams) (ModuleVersion, error) {
	row := q.db.QueryRowContext(ctx, insertModuleVersion, arg.ModuleID, arg.Version)
	var i ModuleVersion
	err := row.Scan(&i.ID, &i.ModuleID, &i.Version)
	return i, err
}

const insertPackage = `-- name: InsertPackage :one
INSERT INTO package ( import_path, source, type_id ) VALUES ( ?,?,? ) RETURNING id, import_path, source, type_id, name
`

type InsertPackageParams struct {
	ImportPath string
	Source     string
	TypeID     int64
}

func (q *Queries) InsertPackage(ctx context.Context, arg InsertPackageParams) (Package, error) {
	row := q.db.QueryRowContext(ctx, insertPackage, arg.ImportPath, arg.Source, arg.TypeID)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.ImportPath,
		&i.Source,
		&i.TypeID,
		&i.Name,
	)
	return i, err
}

const insertPackageType = `-- name: InsertPackageType :one
INSERT INTO package_type ( id,name ) VALUES ( ?,? ) RETURNING id, name
`

type InsertPackageTypeParams struct {
	ID   int64
	Name string
}

func (q *Queries) InsertPackageType(ctx context.Context, arg InsertPackageTypeParams) (PackageType, error) {
	row := q.db.QueryRowContext(ctx, insertPackageType, arg.ID, arg.Name)
	var i PackageType
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const insertPackageVersion = `-- name: InsertPackageVersion :one
INSERT INTO package_version ( package_id,version,source_url ) VALUES ( ?,?,? ) RETURNING id, package_id, version, source_url
`

type InsertPackageVersionParams struct {
	PackageID int64
	Version   string
	SourceUrl string
}

func (q *Queries) InsertPackageVersion(ctx context.Context, arg InsertPackageVersionParams) (PackageVersion, error) {
	row := q.db.QueryRowContext(ctx, insertPackageVersion, arg.PackageID, arg.Version, arg.SourceUrl)
	var i PackageVersion
	err := row.Scan(
		&i.ID,
		&i.PackageID,
		&i.Version,
		&i.SourceUrl,
	)
	return i, err
}

const insertProject = `-- name: InsertProject :one
INSERT INTO project ( name,about,repo_url, website ) VALUES ( ?,?,?,? ) RETURNING id, name, repo_url, about, website
`

type InsertProjectParams struct {
	Name    string
	About   string
	RepoUrl string
	Website string
}

func (q *Queries) InsertProject(ctx context.Context, arg InsertProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, insertProject,
		arg.Name,
		arg.About,
		arg.RepoUrl,
		arg.Website,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.RepoUrl,
		&i.About,
		&i.Website,
	)
	return i, err
}

const insertSurvey = `-- name: InsertSurvey :one
INSERT INTO survey ( codebase_id,local_dir ) VALUES ( ?,? ) RETURNING id, codebase_id, local_dir, timestamp
`

type InsertSurveyParams struct {
	CodebaseID int64
	LocalDir   string
}

func (q *Queries) InsertSurvey(ctx context.Context, arg InsertSurveyParams) (Survey, error) {
	row := q.db.QueryRowContext(ctx, insertSurvey, arg.CodebaseID, arg.LocalDir)
	var i Survey
	err := row.Scan(
		&i.ID,
		&i.CodebaseID,
		&i.LocalDir,
		&i.Timestamp,
	)
	return i, err
}

const insertSurveyModule = `-- name: InsertSurveyModule :one
INSERT INTO survey_module ( survey_id, module_id, module_version_id,package_id, file_id ) VALUES ( ?,?,?,?,? ) RETURNING id, survey_id, module_id, module_version_id, package_id, file_id
`

type InsertSurveyModuleParams struct {
	SurveyID        int64
	ModuleID        int64
	ModuleVersionID int64
	PackageID       int64
	FileID          int64
}

func (q *Queries) InsertSurveyModule(ctx context.Context, arg InsertSurveyModuleParams) (SurveyModule, error) {
	row := q.db.QueryRowContext(ctx, insertSurveyModule,
		arg.SurveyID,
		arg.ModuleID,
		arg.ModuleVersionID,
		arg.PackageID,
		arg.FileID,
	)
	var i SurveyModule
	err := row.Scan(
		&i.ID,
		&i.SurveyID,
		&i.ModuleID,
		&i.ModuleVersionID,
		&i.PackageID,
		&i.FileID,
	)
	return i, err
}

const insertSymbolType = `-- name: InsertSymbolType :one
INSERT INTO symbol_type ( id,name ) VALUES ( ?,? ) RETURNING id, name
`

type InsertSymbolTypeParams struct {
	ID   int64
	Name string
}

func (q *Queries) InsertSymbolType(ctx context.Context, arg InsertSymbolTypeParams) (SymbolType, error) {
	row := q.db.QueryRowContext(ctx, insertSymbolType, arg.ID, arg.Name)
	var i SymbolType
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const insertType = `-- name: InsertType :one
INSERT INTO type ( file_id, survey_id,symbol_type_id, name,definition ) VALUES ( ?,?,?,?,? ) RETURNING id, file_id, survey_id, symbol_type_id, name, definition
`

type InsertTypeParams struct {
	FileID       int64
	SurveyID     int64
	SymbolTypeID int64
	Name         string
	Definition   string
}

func (q *Queries) InsertType(ctx context.Context, arg InsertTypeParams) (Type, error) {
	row := q.db.QueryRowContext(ctx, insertType,
		arg.FileID,
		arg.SurveyID,
		arg.SymbolTypeID,
		arg.Name,
		arg.Definition,
	)
	var i Type
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.SurveyID,
		&i.SymbolTypeID,
		&i.Name,
		&i.Definition,
	)
	return i, err
}

const insertVariable = `-- name: InsertVariable :one
INSERT INTO variable ( name,type_id,survey_id,usage ) VALUES ( ?,?,?,? ) RETURNING id, name, survey_id, type_id, usage, is_param, is_result
`

type InsertVariableParams struct {
	Name     string
	TypeID   int64
	SurveyID int64
	Usage    int64
}

func (q *Queries) InsertVariable(ctx context.Context, arg InsertVariableParams) (Variable, error) {
	row := q.db.QueryRowContext(ctx, insertVariable,
		arg.Name,
		arg.TypeID,
		arg.SurveyID,
		arg.Usage,
	)
	var i Variable
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SurveyID,
		&i.TypeID,
		&i.Usage,
		&i.IsParam,
		&i.IsResult,
	)
	return i, err
}

const listCategories = `-- name: ListCategories :many
SELECT id, survey_id, name FROM category ORDER BY name
`

func (q *Queries) ListCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.QueryContext(ctx, listCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(&i.ID, &i.SurveyID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCodebaseSurveys = `-- name: ListCodebaseSurveys :many
SELECT id, codebase_id, local_dir, timestamp FROM survey WHERE codebase_id = ? ORDER BY timestamp
`

func (q *Queries) ListCodebaseSurveys(ctx context.Context, codebaseID int64) ([]Survey, error) {
	rows, err := q.db.QueryContext(ctx, listCodebaseSurveys, codebaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Survey
	for rows.Next() {
		var i Survey
		if err := rows.Scan(
			&i.ID,
			&i.CodebaseID,
			&i.LocalDir,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCodebases = `-- name: ListCodebases :many
SELECT id, project_id, version_tag, source_url FROM codebase ORDER BY project_id,version_tag
`

func (q *Queries) ListCodebases(ctx context.Context) ([]Codebase, error) {
	rows, err := q.db.QueryContext(ctx, listCodebases)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Codebase
	for rows.Next() {
		var i Codebase
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.VersionTag,
			&i.SourceUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFiles = `-- name: ListFiles :many
SELECT id, survey_id, filepath FROM file ORDER BY filepath
`

func (q *Queries) ListFiles(ctx context.Context) ([]File, error) {
	rows, err := q.db.QueryContext(ctx, listFiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(&i.ID, &i.SurveyID, &i.Filepath); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilesBySurvey = `-- name: ListFilesBySurvey :many
SELECT id, survey_id, filepath FROM file WHERE survey_id= ? ORDER BY filepath
`

func (q *Queries) ListFilesBySurvey(ctx context.Context, surveyID int64) ([]File, error) {
	rows, err := q.db.QueryContext(ctx, listFilesBySurvey, surveyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(&i.ID, &i.SurveyID, &i.Filepath); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listImports = `-- name: ListImports :many
SELECT id, file_id, survey_id, package_id, alias FROM import ORDER BY file_id
`

func (q *Queries) ListImports(ctx context.Context) ([]Import, error) {
	rows, err := q.db.QueryContext(ctx, listImports)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Import
	for rows.Next() {
		var i Import
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.SurveyID,
			&i.PackageID,
			&i.Alias,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMethods = `-- name: ListMethods :many
SELECT id, name, params, results, file_id, survey_id, type_id FROM method ORDER BY survey_id,file_id,type_id,name
`

func (q *Queries) ListMethods(ctx context.Context) ([]Method, error) {
	rows, err := q.db.QueryContext(ctx, listMethods)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Method
	for rows.Next() {
		var i Method
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Params,
			&i.Results,
			&i.FileID,
			&i.SurveyID,
			&i.TypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listModuleVersions = `-- name: ListModuleVersions :many
SELECT id, module_id, version FROM module_version ORDER BY module_id,version
`

func (q *Queries) ListModuleVersions(ctx context.Context) ([]ModuleVersion, error) {
	rows, err := q.db.QueryContext(ctx, listModuleVersions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ModuleVersion
	for rows.Next() {
		var i ModuleVersion
		if err := rows.Scan(&i.ID, &i.ModuleID, &i.Version); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listModules = `-- name: ListModules :many
SELECT id, name FROM module ORDER BY name
`

func (q *Queries) ListModules(ctx context.Context) ([]Module, error) {
	rows, err := q.db.QueryContext(ctx, listModules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Module
	for rows.Next() {
		var i Module
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPackageTypes = `-- name: ListPackageTypes :many
SELECT id, name FROM package_type ORDER BY id
`

func (q *Queries) ListPackageTypes(ctx context.Context) ([]PackageType, error) {
	rows, err := q.db.QueryContext(ctx, listPackageTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PackageType
	for rows.Next() {
		var i PackageType
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPackageTypesByName = `-- name: ListPackageTypesByName :many
SELECT id, name FROM package_type ORDER BY name
`

func (q *Queries) ListPackageTypesByName(ctx context.Context) ([]PackageType, error) {
	rows, err := q.db.QueryContext(ctx, listPackageTypesByName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PackageType
	for rows.Next() {
		var i PackageType
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPackageVersions = `-- name: ListPackageVersions :many
SELECT id, package_id, version, source_url FROM package_version ORDER BY package_id,version
`

func (q *Queries) ListPackageVersions(ctx context.Context) ([]PackageVersion, error) {
	rows, err := q.db.QueryContext(ctx, listPackageVersions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PackageVersion
	for rows.Next() {
		var i PackageVersion
		if err := rows.Scan(
			&i.ID,
			&i.PackageID,
			&i.Version,
			&i.SourceUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPackages = `-- name: ListPackages :many
SELECT id, import_path, source, type_id, name FROM package ORDER BY import_path
`

func (q *Queries) ListPackages(ctx context.Context) ([]Package, error) {
	rows, err := q.db.QueryContext(ctx, listPackages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Package
	for rows.Next() {
		var i Package
		if err := rows.Scan(
			&i.ID,
			&i.ImportPath,
			&i.Source,
			&i.TypeID,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjects = `-- name: ListProjects :many
SELECT id, name, repo_url, about, website FROM project ORDER BY name
`

func (q *Queries) ListProjects(ctx context.Context) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, listProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.RepoUrl,
			&i.About,
			&i.Website,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSurveyModules = `-- name: ListSurveyModules :many
SELECT id, survey_id, module_id, module_version_id, package_id, file_id FROM survey_module ORDER BY survey_id,module_id,module_version_id,package_id
`

func (q *Queries) ListSurveyModules(ctx context.Context) ([]SurveyModule, error) {
	rows, err := q.db.QueryContext(ctx, listSurveyModules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SurveyModule
	for rows.Next() {
		var i SurveyModule
		if err := rows.Scan(
			&i.ID,
			&i.SurveyID,
			&i.ModuleID,
			&i.ModuleVersionID,
			&i.PackageID,
			&i.FileID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSurveys = `-- name: ListSurveys :many
SELECT
    sv.id,
    cb.source_url,
    sv.local_dir,
    sv.timestamp
FROM survey AS sv
    JOIN codebase cb ON cb.id=sv.codebase_id
    JOIN project cb ON cb.id=sv.codebase_id
ORDER BY timestamp
`

type ListSurveysRow struct {
	ID        int64
	SourceUrl string
	LocalDir  string
	Timestamp string
}

func (q *Queries) ListSurveys(ctx context.Context) ([]ListSurveysRow, error) {
	rows, err := q.db.QueryContext(ctx, listSurveys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSurveysRow
	for rows.Next() {
		var i ListSurveysRow
		if err := rows.Scan(
			&i.ID,
			&i.SourceUrl,
			&i.LocalDir,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSymbolTypes = `-- name: ListSymbolTypes :many
SELECT id, name FROM symbol_type ORDER BY id
`

func (q *Queries) ListSymbolTypes(ctx context.Context) ([]SymbolType, error) {
	rows, err := q.db.QueryContext(ctx, listSymbolTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SymbolType
	for rows.Next() {
		var i SymbolType
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSymbolTypesByName = `-- name: ListSymbolTypesByName :many
SELECT id, name FROM symbol_type ORDER BY name
`

func (q *Queries) ListSymbolTypesByName(ctx context.Context) ([]SymbolType, error) {
	rows, err := q.db.QueryContext(ctx, listSymbolTypesByName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SymbolType
	for rows.Next() {
		var i SymbolType
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTypes = `-- name: ListTypes :many
SELECT id, project, filepath, name, symbol_name, survey_id, file_id, symbol_type_id, codebase_id, definition, timestamp, source_url, repo_url, about_project, local_dir FROM type_view ORDER BY name
`

func (q *Queries) ListTypes(ctx context.Context) ([]TypeView, error) {
	rows, err := q.db.QueryContext(ctx, listTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TypeView
	for rows.Next() {
		var i TypeView
		if err := rows.Scan(
			&i.ID,
			&i.Project,
			&i.Filepath,
			&i.Name,
			&i.SymbolName,
			&i.SurveyID,
			&i.FileID,
			&i.SymbolTypeID,
			&i.CodebaseID,
			&i.Definition,
			&i.Timestamp,
			&i.SourceUrl,
			&i.RepoUrl,
			&i.AboutProject,
			&i.LocalDir,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTypesByFile = `-- name: ListTypesByFile :many
SELECT id, project, filepath, name, symbol_name, survey_id, file_id, symbol_type_id, codebase_id, definition, timestamp, source_url, repo_url, about_project, local_dir FROM type_view WHERE file_id = ?
`

func (q *Queries) ListTypesByFile(ctx context.Context, fileID int64) ([]TypeView, error) {
	rows, err := q.db.QueryContext(ctx, listTypesByFile, fileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TypeView
	for rows.Next() {
		var i TypeView
		if err := rows.Scan(
			&i.ID,
			&i.Project,
			&i.Filepath,
			&i.Name,
			&i.SymbolName,
			&i.SurveyID,
			&i.FileID,
			&i.SymbolTypeID,
			&i.CodebaseID,
			&i.Definition,
			&i.Timestamp,
			&i.SourceUrl,
			&i.RepoUrl,
			&i.AboutProject,
			&i.LocalDir,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTypesBySurvey = `-- name: ListTypesBySurvey :many
SELECT id, project, filepath, name, symbol_name, survey_id, file_id, symbol_type_id, codebase_id, definition, timestamp, source_url, repo_url, about_project, local_dir FROM type_view WHERE survey_id = ?
`

func (q *Queries) ListTypesBySurvey(ctx context.Context, surveyID int64) ([]TypeView, error) {
	rows, err := q.db.QueryContext(ctx, listTypesBySurvey, surveyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TypeView
	for rows.Next() {
		var i TypeView
		if err := rows.Scan(
			&i.ID,
			&i.Project,
			&i.Filepath,
			&i.Name,
			&i.SymbolName,
			&i.SurveyID,
			&i.FileID,
			&i.SymbolTypeID,
			&i.CodebaseID,
			&i.Definition,
			&i.Timestamp,
			&i.SourceUrl,
			&i.RepoUrl,
			&i.AboutProject,
			&i.LocalDir,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVariables = `-- name: ListVariables :many
SELECT id, name, survey_id, type_id, usage, is_param, is_result FROM variable ORDER BY survey_id,type_id,is_result,name
`

func (q *Queries) ListVariables(ctx context.Context) ([]Variable, error) {
	rows, err := q.db.QueryContext(ctx, listVariables)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Variable
	for rows.Next() {
		var i Variable
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.SurveyID,
			&i.TypeID,
			&i.Usage,
			&i.IsParam,
			&i.IsResult,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loadCategory = `-- name: LoadCategory :one
SELECT id, survey_id, name FROM category WHERE id = ? LIMIT 1
`

func (q *Queries) LoadCategory(ctx context.Context, id int64) (Category, error) {
	row := q.db.QueryRowContext(ctx, loadCategory, id)
	var i Category
	err := row.Scan(&i.ID, &i.SurveyID, &i.Name)
	return i, err
}

const loadCodebase = `-- name: LoadCodebase :one
SELECT id, project_id, version_tag, source_url FROM codebase WHERE id = ? LIMIT 1
`

func (q *Queries) LoadCodebase(ctx context.Context, id int64) (Codebase, error) {
	row := q.db.QueryRowContext(ctx, loadCodebase, id)
	var i Codebase
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.VersionTag,
		&i.SourceUrl,
	)
	return i, err
}

const loadCodebaseIDByProjectAndVersion = `-- name: LoadCodebaseIDByProjectAndVersion :one
SELECT c.id FROM codebase c JOIN project p ON p.id=c.project_id WHERE p.name = ? AND c.version_tag = ? LIMIT 1
`

type LoadCodebaseIDByProjectAndVersionParams struct {
	Name       string
	VersionTag string
}

func (q *Queries) LoadCodebaseIDByProjectAndVersion(ctx context.Context, arg LoadCodebaseIDByProjectAndVersionParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, loadCodebaseIDByProjectAndVersion, arg.Name, arg.VersionTag)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const loadCodebaseIdByRepoURL = `-- name: LoadCodebaseIdByRepoURL :one
SELECT c.id FROM codebase c JOIN project p ON p.id=c.project_id WHERE p.repo_url = ? LIMIT 1
`

func (q *Queries) LoadCodebaseIdByRepoURL(ctx context.Context, repoUrl string) (int64, error) {
	row := q.db.QueryRowContext(ctx, loadCodebaseIdByRepoURL, repoUrl)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const loadFile = `-- name: LoadFile :one
SELECT id, survey_id, filepath FROM file WHERE id = ? LIMIT 1
`

func (q *Queries) LoadFile(ctx context.Context, id int64) (File, error) {
	row := q.db.QueryRowContext(ctx, loadFile, id)
	var i File
	err := row.Scan(&i.ID, &i.SurveyID, &i.Filepath)
	return i, err
}

const loadImport = `-- name: LoadImport :one
SELECT id, file_id, survey_id, package_id, alias FROM import WHERE id = ? LIMIT 1
`

func (q *Queries) LoadImport(ctx context.Context, id int64) (Import, error) {
	row := q.db.QueryRowContext(ctx, loadImport, id)
	var i Import
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.SurveyID,
		&i.PackageID,
		&i.Alias,
	)
	return i, err
}

const loadMethod = `-- name: LoadMethod :one
SELECT id, name, params, results, file_id, survey_id, type_id FROM method WHERE id = ? LIMIT 1
`

func (q *Queries) LoadMethod(ctx context.Context, id int64) (Method, error) {
	row := q.db.QueryRowContext(ctx, loadMethod, id)
	var i Method
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Params,
		&i.Results,
		&i.FileID,
		&i.SurveyID,
		&i.TypeID,
	)
	return i, err
}

const loadModule = `-- name: LoadModule :one
SELECT id, name FROM module WHERE id = ? LIMIT 1
`

func (q *Queries) LoadModule(ctx context.Context, id int64) (Module, error) {
	row := q.db.QueryRowContext(ctx, loadModule, id)
	var i Module
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const loadModuleVersion = `-- name: LoadModuleVersion :one
SELECT id, module_id, version FROM module_version WHERE id = ? LIMIT 1
`

func (q *Queries) LoadModuleVersion(ctx context.Context, id int64) (ModuleVersion, error) {
	row := q.db.QueryRowContext(ctx, loadModuleVersion, id)
	var i ModuleVersion
	err := row.Scan(&i.ID, &i.ModuleID, &i.Version)
	return i, err
}

const loadPackage = `-- name: LoadPackage :one
SELECT id, import_path, source, type_id, name FROM package WHERE id = ? LIMIT 1
`

func (q *Queries) LoadPackage(ctx context.Context, id int64) (Package, error) {
	row := q.db.QueryRowContext(ctx, loadPackage, id)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.ImportPath,
		&i.Source,
		&i.TypeID,
		&i.Name,
	)
	return i, err
}

const loadPackageType = `-- name: LoadPackageType :one
SELECT id, name FROM package_type WHERE id = ? LIMIT 1
`

func (q *Queries) LoadPackageType(ctx context.Context, id int64) (PackageType, error) {
	row := q.db.QueryRowContext(ctx, loadPackageType, id)
	var i PackageType
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const loadPackageVersion = `-- name: LoadPackageVersion :one
SELECT id, package_id, version, source_url FROM package_version WHERE id = ? LIMIT 1
`

func (q *Queries) LoadPackageVersion(ctx context.Context, id int64) (PackageVersion, error) {
	row := q.db.QueryRowContext(ctx, loadPackageVersion, id)
	var i PackageVersion
	err := row.Scan(
		&i.ID,
		&i.PackageID,
		&i.Version,
		&i.SourceUrl,
	)
	return i, err
}

const loadProject = `-- name: LoadProject :one
SELECT id, name, repo_url, about, website FROM project WHERE id = ? LIMIT 1
`

func (q *Queries) LoadProject(ctx context.Context, id int64) (Project, error) {
	row := q.db.QueryRowContext(ctx, loadProject, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.RepoUrl,
		&i.About,
		&i.Website,
	)
	return i, err
}

const loadProjectByName = `-- name: LoadProjectByName :one
SELECT id, name, repo_url, about, website FROM project WHERE name = ? LIMIT 1
`

func (q *Queries) LoadProjectByName(ctx context.Context, name string) (Project, error) {
	row := q.db.QueryRowContext(ctx, loadProjectByName, name)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.RepoUrl,
		&i.About,
		&i.Website,
	)
	return i, err
}

const loadProjectByRepoURL = `-- name: LoadProjectByRepoURL :one
SELECT id, name, repo_url, about, website FROM project WHERE repo_url = ? LIMIT 1
`

func (q *Queries) LoadProjectByRepoURL(ctx context.Context, repoUrl string) (Project, error) {
	row := q.db.QueryRowContext(ctx, loadProjectByRepoURL, repoUrl)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.RepoUrl,
		&i.About,
		&i.Website,
	)
	return i, err
}

const loadProjectRepoURL = `-- name: LoadProjectRepoURL :one
SELECT repo_url FROM project WHERE id = ? LIMIT 1
`

func (q *Queries) LoadProjectRepoURL(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRowContext(ctx, loadProjectRepoURL, id)
	var repo_url string
	err := row.Scan(&repo_url)
	return repo_url, err
}

const loadSurvey = `-- name: LoadSurvey :one
SELECT id, codebase_id, local_dir, timestamp FROM survey WHERE id = ? LIMIT 1
`

func (q *Queries) LoadSurvey(ctx context.Context, id int64) (Survey, error) {
	row := q.db.QueryRowContext(ctx, loadSurvey, id)
	var i Survey
	err := row.Scan(
		&i.ID,
		&i.CodebaseID,
		&i.LocalDir,
		&i.Timestamp,
	)
	return i, err
}

const loadSurveyByRepoURL = `-- name: LoadSurveyByRepoURL :one
SELECT s.id, codebase_id, local_dir, timestamp, c.id, project_id, version_tag, source_url, p.id, name, repo_url, about, website FROM survey s JOIN codebase c ON c.id=s.codebase_id  JOIN project p ON p.id=c.project_id WHERE p.repo_url = ? LIMIT 1
`

type LoadSurveyByRepoURLRow struct {
	ID         int64
	CodebaseID int64
	LocalDir   string
	Timestamp  string
	ID_2       int64
	ProjectID  int64
	VersionTag string
	SourceUrl  string
	ID_3       int64
	Name       string
	RepoUrl    string
	About      string
	Website    string
}

func (q *Queries) LoadSurveyByRepoURL(ctx context.Context, repoUrl string) (LoadSurveyByRepoURLRow, error) {
	row := q.db.QueryRowContext(ctx, loadSurveyByRepoURL, repoUrl)
	var i LoadSurveyByRepoURLRow
	err := row.Scan(
		&i.ID,
		&i.CodebaseID,
		&i.LocalDir,
		&i.Timestamp,
		&i.ID_2,
		&i.ProjectID,
		&i.VersionTag,
		&i.SourceUrl,
		&i.ID_3,
		&i.Name,
		&i.RepoUrl,
		&i.About,
		&i.Website,
	)
	return i, err
}

const loadSurveyModule = `-- name: LoadSurveyModule :one
SELECT id, survey_id, module_id, module_version_id, package_id, file_id FROM survey_module WHERE id = ? LIMIT 1
`

func (q *Queries) LoadSurveyModule(ctx context.Context, id int64) (SurveyModule, error) {
	row := q.db.QueryRowContext(ctx, loadSurveyModule, id)
	var i SurveyModule
	err := row.Scan(
		&i.ID,
		&i.SurveyID,
		&i.ModuleID,
		&i.ModuleVersionID,
		&i.PackageID,
		&i.FileID,
	)
	return i, err
}

const loadSymbolType = `-- name: LoadSymbolType :one
SELECT id, name FROM symbol_type WHERE id = ? LIMIT 1
`

func (q *Queries) LoadSymbolType(ctx context.Context, id int64) (SymbolType, error) {
	row := q.db.QueryRowContext(ctx, loadSymbolType, id)
	var i SymbolType
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const loadType = `-- name: LoadType :one
SELECT id, file_id, survey_id, symbol_type_id, name, definition FROM type WHERE id = ? LIMIT 1
`

func (q *Queries) LoadType(ctx context.Context, id int64) (Type, error) {
	row := q.db.QueryRowContext(ctx, loadType, id)
	var i Type
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.SurveyID,
		&i.SymbolTypeID,
		&i.Name,
		&i.Definition,
	)
	return i, err
}

const loadVariable = `-- name: LoadVariable :one
SELECT id, name, survey_id, type_id, usage, is_param, is_result FROM variable WHERE id = ? LIMIT 1
`

func (q *Queries) LoadVariable(ctx context.Context, id int64) (Variable, error) {
	row := q.db.QueryRowContext(ctx, loadVariable, id)
	var i Variable
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SurveyID,
		&i.TypeID,
		&i.Usage,
		&i.IsParam,
		&i.IsResult,
	)
	return i, err
}

const updateCategory = `-- name: UpdateCategory :exec
UPDATE category SET name = ? WHERE id = ? RETURNING id, survey_id, name
`

type UpdateCategoryParams struct {
	Name string
	ID   int64
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) error {
	_, err := q.db.ExecContext(ctx, updateCategory, arg.Name, arg.ID)
	return err
}

const updateCodebase = `-- name: UpdateCodebase :exec
UPDATE codebase SET project_id = ?, version_tag = ?, source_url = ? WHERE id = ? RETURNING id, project_id, version_tag, source_url
`

type UpdateCodebaseParams struct {
	ProjectID  int64
	VersionTag string
	SourceUrl  string
	ID         int64
}

func (q *Queries) UpdateCodebase(ctx context.Context, arg UpdateCodebaseParams) error {
	_, err := q.db.ExecContext(ctx, updateCodebase,
		arg.ProjectID,
		arg.VersionTag,
		arg.SourceUrl,
		arg.ID,
	)
	return err
}

const updateCodebaseByProjectIdAndVersionTag = `-- name: UpdateCodebaseByProjectIdAndVersionTag :exec
UPDATE codebase SET source_url = ? WHERE project_id = ? AND version_tag = ? RETURNING id, project_id, version_tag, source_url
`

type UpdateCodebaseByProjectIdAndVersionTagParams struct {
	SourceUrl  string
	ProjectID  int64
	VersionTag string
}

func (q *Queries) UpdateCodebaseByProjectIdAndVersionTag(ctx context.Context, arg UpdateCodebaseByProjectIdAndVersionTagParams) error {
	_, err := q.db.ExecContext(ctx, updateCodebaseByProjectIdAndVersionTag, arg.SourceUrl, arg.ProjectID, arg.VersionTag)
	return err
}

const updateFile = `-- name: UpdateFile :exec
UPDATE file SET filepath = ? WHERE id = ? RETURNING id, survey_id, filepath
`

type UpdateFileParams struct {
	Filepath string
	ID       int64
}

func (q *Queries) UpdateFile(ctx context.Context, arg UpdateFileParams) error {
	_, err := q.db.ExecContext(ctx, updateFile, arg.Filepath, arg.ID)
	return err
}

const updateImport = `-- name: UpdateImport :exec
UPDATE import SET file_id = ?, survey_id = ?, package_id = ? WHERE id = ? RETURNING id, file_id, survey_id, package_id, alias
`

type UpdateImportParams struct {
	FileID    int64
	SurveyID  int64
	PackageID int64
	ID        int64
}

func (q *Queries) UpdateImport(ctx context.Context, arg UpdateImportParams) error {
	_, err := q.db.ExecContext(ctx, updateImport,
		arg.FileID,
		arg.SurveyID,
		arg.PackageID,
		arg.ID,
	)
	return err
}

const updateMethod = `-- name: UpdateMethod :exec
UPDATE method SET name = ?,params = ?,results = ?,type_id = ?,file_id = ?,survey_id = ? WHERE id = ? RETURNING id, name, params, results, file_id, survey_id, type_id
`

type UpdateMethodParams struct {
	Name     string
	Params   string
	Results  string
	TypeID   int64
	FileID   int64
	SurveyID int64
	ID       int64
}

func (q *Queries) UpdateMethod(ctx context.Context, arg UpdateMethodParams) error {
	_, err := q.db.ExecContext(ctx, updateMethod,
		arg.Name,
		arg.Params,
		arg.Results,
		arg.TypeID,
		arg.FileID,
		arg.SurveyID,
		arg.ID,
	)
	return err
}

const updateModule = `-- name: UpdateModule :exec
UPDATE module SET name = ? WHERE id = ? RETURNING id, name
`

type UpdateModuleParams struct {
	Name string
	ID   int64
}

func (q *Queries) UpdateModule(ctx context.Context, arg UpdateModuleParams) error {
	_, err := q.db.ExecContext(ctx, updateModule, arg.Name, arg.ID)
	return err
}

const updateModuleVersion = `-- name: UpdateModuleVersion :exec
UPDATE module_version SET module_id = ?, version = ? WHERE id = ? RETURNING id, module_id, version
`

type UpdateModuleVersionParams struct {
	ModuleID int64
	Version  string
	ID       int64
}

func (q *Queries) UpdateModuleVersion(ctx context.Context, arg UpdateModuleVersionParams) error {
	_, err := q.db.ExecContext(ctx, updateModuleVersion, arg.ModuleID, arg.Version, arg.ID)
	return err
}

const updatePackage = `-- name: UpdatePackage :exec
UPDATE package SET import_path = ?, source = ?, type_id = ? WHERE id = ? RETURNING id, import_path, source, type_id, name
`

type UpdatePackageParams struct {
	ImportPath string
	Source     string
	TypeID     int64
	ID         int64
}

func (q *Queries) UpdatePackage(ctx context.Context, arg UpdatePackageParams) error {
	_, err := q.db.ExecContext(ctx, updatePackage,
		arg.ImportPath,
		arg.Source,
		arg.TypeID,
		arg.ID,
	)
	return err
}

const updatePackageType = `-- name: UpdatePackageType :exec
UPDATE package_type SET name = ? WHERE id = ? RETURNING id, name
`

type UpdatePackageTypeParams struct {
	Name string
	ID   int64
}

func (q *Queries) UpdatePackageType(ctx context.Context, arg UpdatePackageTypeParams) error {
	_, err := q.db.ExecContext(ctx, updatePackageType, arg.Name, arg.ID)
	return err
}

const updatePackageVersion = `-- name: UpdatePackageVersion :exec
UPDATE package_version SET package_id = ?, version = ?, source_url = ? WHERE id = ? RETURNING id, package_id, version, source_url
`

type UpdatePackageVersionParams struct {
	PackageID int64
	Version   string
	SourceUrl string
	ID        int64
}

func (q *Queries) UpdatePackageVersion(ctx context.Context, arg UpdatePackageVersionParams) error {
	_, err := q.db.ExecContext(ctx, updatePackageVersion,
		arg.PackageID,
		arg.Version,
		arg.SourceUrl,
		arg.ID,
	)
	return err
}

const updateProject = `-- name: UpdateProject :exec
UPDATE project SET name = ?, about = ?, repo_url = ?, website = ? WHERE id = ? RETURNING id, name, repo_url, about, website
`

type UpdateProjectParams struct {
	Name    string
	About   string
	RepoUrl string
	Website string
	ID      int64
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) error {
	_, err := q.db.ExecContext(ctx, updateProject,
		arg.Name,
		arg.About,
		arg.RepoUrl,
		arg.Website,
		arg.ID,
	)
	return err
}

const updateProjectByName = `-- name: UpdateProjectByName :exec
UPDATE project SET repo_url = ?, about = ?, website = ? WHERE name = ? RETURNING id, name, repo_url, about, website
`

type UpdateProjectByNameParams struct {
	RepoUrl string
	About   string
	Website string
	Name    string
}

func (q *Queries) UpdateProjectByName(ctx context.Context, arg UpdateProjectByNameParams) error {
	_, err := q.db.ExecContext(ctx, updateProjectByName,
		arg.RepoUrl,
		arg.About,
		arg.Website,
		arg.Name,
	)
	return err
}

const updateSurveyModule = `-- name: UpdateSurveyModule :exec
UPDATE survey_module SET survey_id = ?, module_id = ?, module_version_id = ?, file_id = ?, package_id = ? WHERE id = ? RETURNING id, survey_id, module_id, module_version_id, package_id, file_id
`

type UpdateSurveyModuleParams struct {
	SurveyID        int64
	ModuleID        int64
	ModuleVersionID int64
	FileID          int64
	PackageID       int64
	ID              int64
}

func (q *Queries) UpdateSurveyModule(ctx context.Context, arg UpdateSurveyModuleParams) error {
	_, err := q.db.ExecContext(ctx, updateSurveyModule,
		arg.SurveyID,
		arg.ModuleID,
		arg.ModuleVersionID,
		arg.FileID,
		arg.PackageID,
		arg.ID,
	)
	return err
}

const updateSymbolType = `-- name: UpdateSymbolType :exec
UPDATE symbol_type SET name = ? WHERE id = ? RETURNING id, name
`

type UpdateSymbolTypeParams struct {
	Name string
	ID   int64
}

func (q *Queries) UpdateSymbolType(ctx context.Context, arg UpdateSymbolTypeParams) error {
	_, err := q.db.ExecContext(ctx, updateSymbolType, arg.Name, arg.ID)
	return err
}

const updateType = `-- name: UpdateType :exec
UPDATE type SET file_id= ?, symbol_type_id= ?, name= ?,definition= ? WHERE id = ? RETURNING id, file_id, survey_id, symbol_type_id, name, definition
`

type UpdateTypeParams struct {
	FileID       int64
	SymbolTypeID int64
	Name         string
	Definition   string
	ID           int64
}

func (q *Queries) UpdateType(ctx context.Context, arg UpdateTypeParams) error {
	_, err := q.db.ExecContext(ctx, updateType,
		arg.FileID,
		arg.SymbolTypeID,
		arg.Name,
		arg.Definition,
		arg.ID,
	)
	return err
}

const updateVariable = `-- name: UpdateVariable :exec
UPDATE variable SET name = ?,survey_id = ?,type_id = ?,usage=? WHERE id = ? RETURNING id, name, survey_id, type_id, usage, is_param, is_result
`

type UpdateVariableParams struct {
	Name     string
	SurveyID int64
	TypeID   int64
	Usage    int64
	ID       int64
}

func (q *Queries) UpdateVariable(ctx context.Context, arg UpdateVariableParams) error {
	_, err := q.db.ExecContext(ctx, updateVariable,
		arg.Name,
		arg.SurveyID,
		arg.TypeID,
		arg.Usage,
		arg.ID,
	)
	return err
}

const upsertCategory = `-- name: UpsertCategory :one
INSERT INTO category ( survey_id,name ) VALUES ( ?,? )
ON CONFLICT (survey_id,name) DO UPDATE SET name=excluded.name RETURNING id, survey_id, name
`

type UpsertCategoryParams struct {
	SurveyID int64
	Name     string
}

func (q *Queries) UpsertCategory(ctx context.Context, arg UpsertCategoryParams) (Category, error) {
	row := q.db.QueryRowContext(ctx, upsertCategory, arg.SurveyID, arg.Name)
	var i Category
	err := row.Scan(&i.ID, &i.SurveyID, &i.Name)
	return i, err
}

const upsertCodebase = `-- name: UpsertCodebase :one
INSERT INTO codebase ( project_id,version_tag,source_url ) VALUES ( ?,?,? )
ON CONFLICT (project_id,version_tag) DO UPDATE SET source_url=excluded.source_url,version_tag=excluded.version_tag RETURNING id, project_id, version_tag, source_url
`

type UpsertCodebaseParams struct {
	ProjectID  int64
	VersionTag string
	SourceUrl  string
}

func (q *Queries) UpsertCodebase(ctx context.Context, arg UpsertCodebaseParams) (Codebase, error) {
	row := q.db.QueryRowContext(ctx, upsertCodebase, arg.ProjectID, arg.VersionTag, arg.SourceUrl)
	var i Codebase
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.VersionTag,
		&i.SourceUrl,
	)
	return i, err
}

const upsertFile = `-- name: UpsertFile :one
INSERT INTO file (survey_id,filepath) VALUES ( ?,? )
ON CONFLICT (survey_id,filepath) DO UPDATE SET filepath=excluded.filepath RETURNING id, survey_id, filepath
`

type UpsertFileParams struct {
	SurveyID int64
	Filepath string
}

func (q *Queries) UpsertFile(ctx context.Context, arg UpsertFileParams) (File, error) {
	row := q.db.QueryRowContext(ctx, upsertFile, arg.SurveyID, arg.Filepath)
	var i File
	err := row.Scan(&i.ID, &i.SurveyID, &i.Filepath)
	return i, err
}

const upsertImport = `-- name: UpsertImport :one
INSERT INTO import ( file_id, survey_id, package_id, alias ) VALUES ( ?,?,?,? )
ON CONFLICT (file_id, survey_id, package_id, alias) DO UPDATE SET alias=excluded.alias RETURNING id, file_id, survey_id, package_id, alias
`

type UpsertImportParams struct {
	FileID    int64
	SurveyID  int64
	PackageID int64
	Alias     string
}

func (q *Queries) UpsertImport(ctx context.Context, arg UpsertImportParams) (Import, error) {
	row := q.db.QueryRowContext(ctx, upsertImport,
		arg.FileID,
		arg.SurveyID,
		arg.PackageID,
		arg.Alias,
	)
	var i Import
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.SurveyID,
		&i.PackageID,
		&i.Alias,
	)
	return i, err
}

const upsertModule = `-- name: UpsertModule :one
INSERT INTO module ( name ) VALUES ( ? )
ON CONFLICT (name) DO UPDATE SET name=excluded.name RETURNING id, name
`

func (q *Queries) UpsertModule(ctx context.Context, name string) (Module, error) {
	row := q.db.QueryRowContext(ctx, upsertModule, name)
	var i Module
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const upsertModuleVersion = `-- name: UpsertModuleVersion :one
INSERT INTO module_version ( module_id, version ) VALUES ( ?,? )
ON CONFLICT (module_id,version) DO UPDATE SET version=excluded.version RETURNING id, module_id, version
`

type UpsertModuleVersionParams struct {
	ModuleID int64
	Version  string
}

func (q *Queries) UpsertModuleVersion(ctx context.Context, arg UpsertModuleVersionParams) (ModuleVersion, error) {
	row := q.db.QueryRowContext(ctx, upsertModuleVersion, arg.ModuleID, arg.Version)
	var i ModuleVersion
	err := row.Scan(&i.ID, &i.ModuleID, &i.Version)
	return i, err
}

const upsertPackage = `-- name: UpsertPackage :one
INSERT INTO package ( import_path, source, type_id ) VALUES ( ?,?,? )
ON CONFLICT (import_path, source) DO UPDATE SET import_path=excluded.import_path, source=excluded.source, type_id=excluded.type_id RETURNING id, import_path, source, type_id, name
`

type UpsertPackageParams struct {
	ImportPath string
	Source     string
	TypeID     int64
}

func (q *Queries) UpsertPackage(ctx context.Context, arg UpsertPackageParams) (Package, error) {
	row := q.db.QueryRowContext(ctx, upsertPackage, arg.ImportPath, arg.Source, arg.TypeID)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.ImportPath,
		&i.Source,
		&i.TypeID,
		&i.Name,
	)
	return i, err
}

const upsertPackageType = `-- name: UpsertPackageType :one
INSERT INTO package_type ( id,name ) VALUES ( ?,? )
ON CONFLICT (id) DO UPDATE SET name=excluded.name RETURNING id, name
`

type UpsertPackageTypeParams struct {
	ID   int64
	Name string
}

func (q *Queries) UpsertPackageType(ctx context.Context, arg UpsertPackageTypeParams) (PackageType, error) {
	row := q.db.QueryRowContext(ctx, upsertPackageType, arg.ID, arg.Name)
	var i PackageType
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const upsertPackageVersion = `-- name: UpsertPackageVersion :one
INSERT INTO package_version ( package_id,version,source_url ) VALUES ( ?,?,? )
ON CONFLICT (package_id,version) DO UPDATE SET source_url=excluded.source_url RETURNING id, package_id, version, source_url
`

type UpsertPackageVersionParams struct {
	PackageID int64
	Version   string
	SourceUrl string
}

func (q *Queries) UpsertPackageVersion(ctx context.Context, arg UpsertPackageVersionParams) (PackageVersion, error) {
	row := q.db.QueryRowContext(ctx, upsertPackageVersion, arg.PackageID, arg.Version, arg.SourceUrl)
	var i PackageVersion
	err := row.Scan(
		&i.ID,
		&i.PackageID,
		&i.Version,
		&i.SourceUrl,
	)
	return i, err
}

const upsertProject = `-- name: UpsertProject :one
INSERT INTO project ( name,about,repo_url,website ) VALUES ( ?,?,?,? )
ON CONFLICT (name) DO UPDATE SET about=excluded.about, repo_url=excluded.repo_url, website=excluded.website  RETURNING id, name, repo_url, about, website
`

type UpsertProjectParams struct {
	Name    string
	About   string
	RepoUrl string
	Website string
}

func (q *Queries) UpsertProject(ctx context.Context, arg UpsertProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, upsertProject,
		arg.Name,
		arg.About,
		arg.RepoUrl,
		arg.Website,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.RepoUrl,
		&i.About,
		&i.Website,
	)
	return i, err
}

const upsertSurveyModule = `-- name: UpsertSurveyModule :one
INSERT INTO survey_module ( survey_id, module_id, module_version_id, package_id, file_id ) VALUES ( ?,?,?,?,? )
ON CONFLICT (survey_id,module_version_id,file_id) DO UPDATE SET survey_id=excluded.survey_id, module_id=excluded.module_id, module_version_id=excluded.module_version_id, file_id=excluded.file_id RETURNING id, survey_id, module_id, module_version_id, package_id, file_id
`

type UpsertSurveyModuleParams struct {
	SurveyID        int64
	ModuleID        int64
	ModuleVersionID int64
	PackageID       int64
	FileID          int64
}

func (q *Queries) UpsertSurveyModule(ctx context.Context, arg UpsertSurveyModuleParams) (SurveyModule, error) {
	row := q.db.QueryRowContext(ctx, upsertSurveyModule,
		arg.SurveyID,
		arg.ModuleID,
		arg.ModuleVersionID,
		arg.PackageID,
		arg.FileID,
	)
	var i SurveyModule
	err := row.Scan(
		&i.ID,
		&i.SurveyID,
		&i.ModuleID,
		&i.ModuleVersionID,
		&i.PackageID,
		&i.FileID,
	)
	return i, err
}

const upsertSymbolType = `-- name: UpsertSymbolType :one
INSERT INTO symbol_type ( id,name ) VALUES ( ?,? )
    ON CONFLICT (id) DO UPDATE SET name=excluded.name RETURNING id, name
`

type UpsertSymbolTypeParams struct {
	ID   int64
	Name string
}

func (q *Queries) UpsertSymbolType(ctx context.Context, arg UpsertSymbolTypeParams) (SymbolType, error) {
	row := q.db.QueryRowContext(ctx, upsertSymbolType, arg.ID, arg.Name)
	var i SymbolType
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}
