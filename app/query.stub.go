// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package app

import (
	"context"
	"database/sql"
	"github.com/mikeschinkel/gerardus/persister"
	"sync"
)

// DataStoreQueriesStub is a mock implementation of persister.DataStoreQueries.
//
//	func TestSomethingThatUsesDataStoreQueries(t *testing.T) {
//
//		// make and configure a mocked persister.DataStoreQueries
//		mockedDataStoreQueries := &DataStoreQueriesStub{
//			DeleteCategoryFunc: func(ctx context.Context, id int64) error {
//				panic("mock out the DeleteCategory method")
//			},
//			DeleteCodebaseFunc: func(ctx context.Context, id int64) error {
//				panic("mock out the DeleteCodebase method")
//			},
//			DeleteCodebaseByProjectIdAndVersionTagFunc: func(ctx context.Context, arg persister.DeleteCodebaseByProjectIdAndVersionTagParams) error {
//				panic("mock out the DeleteCodebaseByProjectIdAndVersionTag method")
//			},
//			DeleteCodebaseSurveysFunc: func(ctx context.Context, codebaseID int64) error {
//				panic("mock out the DeleteCodebaseSurveys method")
//			},
//			DeleteFileFunc: func(ctx context.Context, id int64) error {
//				panic("mock out the DeleteFile method")
//			},
//			DeleteImportFunc: func(ctx context.Context, id int64) error {
//				panic("mock out the DeleteImport method")
//			},
//			DeleteMethodFunc: func(ctx context.Context, id int64) error {
//				panic("mock out the DeleteMethod method")
//			},
//			DeleteModuleFunc: func(ctx context.Context, id int64) error {
//				panic("mock out the DeleteModule method")
//			},
//			DeleteModuleVersionFunc: func(ctx context.Context, id int64) error {
//				panic("mock out the DeleteModuleVersion method")
//			},
//			DeletePackageFunc: func(ctx context.Context, id int64) error {
//				panic("mock out the DeletePackage method")
//			},
//			DeletePackageTypeFunc: func(ctx context.Context, id int64) error {
//				panic("mock out the DeletePackageType method")
//			},
//			DeletePackageVersionFunc: func(ctx context.Context, id int64) error {
//				panic("mock out the DeletePackageVersion method")
//			},
//			DeleteProjectFunc: func(ctx context.Context, id int64) error {
//				panic("mock out the DeleteProject method")
//			},
//			DeleteProjectByNameFunc: func(ctx context.Context, name string) error {
//				panic("mock out the DeleteProjectByName method")
//			},
//			DeleteSurveyFunc: func(ctx context.Context, id int64) error {
//				panic("mock out the DeleteSurvey method")
//			},
//			DeleteSurveyModuleFunc: func(ctx context.Context, id int64) error {
//				panic("mock out the DeleteSurveyModule method")
//			},
//			DeleteSymbolTypeFunc: func(ctx context.Context, id int64) error {
//				panic("mock out the DeleteSymbolType method")
//			},
//			DeleteTypeFunc: func(ctx context.Context, id int64) error {
//				panic("mock out the DeleteType method")
//			},
//			DeleteVariableFunc: func(ctx context.Context, id int64) error {
//				panic("mock out the DeleteVariable method")
//			},
//			InsertCategoryFunc: func(ctx context.Context, arg persister.InsertCategoryParams) (persister.Category, error) {
//				panic("mock out the InsertCategory method")
//			},
//			InsertCodebaseFunc: func(ctx context.Context, arg persister.InsertCodebaseParams) (persister.Codebase, error) {
//				panic("mock out the InsertCodebase method")
//			},
//			InsertFileFunc: func(ctx context.Context, arg persister.InsertFileParams) (persister.File, error) {
//				panic("mock out the InsertFile method")
//			},
//			InsertImportFunc: func(ctx context.Context, arg persister.InsertImportParams) (persister.Import, error) {
//				panic("mock out the InsertImport method")
//			},
//			InsertMethodFunc: func(ctx context.Context, arg persister.InsertMethodParams) (persister.Method, error) {
//				panic("mock out the InsertMethod method")
//			},
//			InsertModuleFunc: func(ctx context.Context, name string) (persister.Module, error) {
//				panic("mock out the InsertModule method")
//			},
//			InsertModuleVersionFunc: func(ctx context.Context, arg persister.InsertModuleVersionParams) (persister.ModuleVersion, error) {
//				panic("mock out the InsertModuleVersion method")
//			},
//			InsertPackageFunc: func(ctx context.Context, arg persister.InsertPackageParams) (persister.Package, error) {
//				panic("mock out the InsertPackage method")
//			},
//			InsertPackageTypeFunc: func(ctx context.Context, arg persister.InsertPackageTypeParams) (persister.PackageType, error) {
//				panic("mock out the InsertPackageType method")
//			},
//			InsertPackageVersionFunc: func(ctx context.Context, arg persister.InsertPackageVersionParams) (persister.PackageVersion, error) {
//				panic("mock out the InsertPackageVersion method")
//			},
//			InsertProjectFunc: func(ctx context.Context, arg persister.InsertProjectParams) (persister.Project, error) {
//				panic("mock out the InsertProject method")
//			},
//			InsertSurveyFunc: func(ctx context.Context, arg persister.InsertSurveyParams) (persister.Survey, error) {
//				panic("mock out the InsertSurvey method")
//			},
//			InsertSurveyModuleFunc: func(ctx context.Context, arg persister.InsertSurveyModuleParams) (persister.SurveyModule, error) {
//				panic("mock out the InsertSurveyModule method")
//			},
//			InsertSymbolTypeFunc: func(ctx context.Context, arg persister.InsertSymbolTypeParams) (persister.SymbolType, error) {
//				panic("mock out the InsertSymbolType method")
//			},
//			InsertTypeFunc: func(ctx context.Context, arg persister.InsertTypeParams) (persister.Type, error) {
//				panic("mock out the InsertType method")
//			},
//			InsertVariableFunc: func(ctx context.Context, arg persister.InsertVariableParams) (persister.Variable, error) {
//				panic("mock out the InsertVariable method")
//			},
//			ListCategoriesFunc: func(ctx context.Context) ([]persister.Category, error) {
//				panic("mock out the ListCategories method")
//			},
//			ListCodebaseSurveysFunc: func(ctx context.Context, codebaseID int64) ([]persister.Survey, error) {
//				panic("mock out the ListCodebaseSurveys method")
//			},
//			ListCodebasesFunc: func(ctx context.Context) ([]persister.Codebase, error) {
//				panic("mock out the ListCodebases method")
//			},
//			ListFilesFunc: func(ctx context.Context) ([]persister.File, error) {
//				panic("mock out the ListFiles method")
//			},
//			ListFilesBySurveyFunc: func(ctx context.Context, surveyID int64) ([]persister.File, error) {
//				panic("mock out the ListFilesBySurvey method")
//			},
//			ListImportsFunc: func(ctx context.Context) ([]persister.Import, error) {
//				panic("mock out the ListImports method")
//			},
//			ListMethodsFunc: func(ctx context.Context) ([]persister.Method, error) {
//				panic("mock out the ListMethods method")
//			},
//			ListModuleVersionsFunc: func(ctx context.Context) ([]persister.ModuleVersion, error) {
//				panic("mock out the ListModuleVersions method")
//			},
//			ListModulesFunc: func(ctx context.Context) ([]persister.Module, error) {
//				panic("mock out the ListModules method")
//			},
//			ListPackageTypesFunc: func(ctx context.Context) ([]persister.PackageType, error) {
//				panic("mock out the ListPackageTypes method")
//			},
//			ListPackageTypesByNameFunc: func(ctx context.Context) ([]persister.PackageType, error) {
//				panic("mock out the ListPackageTypesByName method")
//			},
//			ListPackageVersionsFunc: func(ctx context.Context) ([]persister.PackageVersion, error) {
//				panic("mock out the ListPackageVersions method")
//			},
//			ListPackagesFunc: func(ctx context.Context) ([]persister.Package, error) {
//				panic("mock out the ListPackages method")
//			},
//			ListProjectsFunc: func(ctx context.Context) ([]persister.Project, error) {
//				panic("mock out the ListProjects method")
//			},
//			ListSurveyModulesFunc: func(ctx context.Context) ([]persister.SurveyModule, error) {
//				panic("mock out the ListSurveyModules method")
//			},
//			ListSurveysFunc: func(ctx context.Context) ([]persister.ListSurveysRow, error) {
//				panic("mock out the ListSurveys method")
//			},
//			ListSymbolTypesFunc: func(ctx context.Context) ([]persister.SymbolType, error) {
//				panic("mock out the ListSymbolTypes method")
//			},
//			ListSymbolTypesByNameFunc: func(ctx context.Context) ([]persister.SymbolType, error) {
//				panic("mock out the ListSymbolTypesByName method")
//			},
//			ListTypesFunc: func(ctx context.Context) ([]persister.TypeView, error) {
//				panic("mock out the ListTypes method")
//			},
//			ListTypesByFileFunc: func(ctx context.Context, fileID int64) ([]persister.TypeView, error) {
//				panic("mock out the ListTypesByFile method")
//			},
//			ListTypesBySurveyFunc: func(ctx context.Context, surveyID int64) ([]persister.TypeView, error) {
//				panic("mock out the ListTypesBySurvey method")
//			},
//			ListVariablesFunc: func(ctx context.Context) ([]persister.Variable, error) {
//				panic("mock out the ListVariables method")
//			},
//			LoadCategoryFunc: func(ctx context.Context, id int64) (persister.Category, error) {
//				panic("mock out the LoadCategory method")
//			},
//			LoadCodebaseFunc: func(ctx context.Context, id int64) (persister.Codebase, error) {
//				panic("mock out the LoadCodebase method")
//			},
//			LoadCodebaseIDByProjectAndVersionFunc: func(ctx context.Context, arg persister.LoadCodebaseIDByProjectAndVersionParams) (int64, error) {
//				panic("mock out the LoadCodebaseIDByProjectAndVersion method")
//			},
//			LoadCodebaseIdByRepoURLFunc: func(ctx context.Context, repoUrl string) (int64, error) {
//				panic("mock out the LoadCodebaseIdByRepoURL method")
//			},
//			LoadFileFunc: func(ctx context.Context, id int64) (persister.File, error) {
//				panic("mock out the LoadFile method")
//			},
//			LoadImportFunc: func(ctx context.Context, id int64) (persister.Import, error) {
//				panic("mock out the LoadImport method")
//			},
//			LoadMethodFunc: func(ctx context.Context, id int64) (persister.Method, error) {
//				panic("mock out the LoadMethod method")
//			},
//			LoadModuleFunc: func(ctx context.Context, id int64) (persister.Module, error) {
//				panic("mock out the LoadModule method")
//			},
//			LoadModuleVersionFunc: func(ctx context.Context, id int64) (persister.ModuleVersion, error) {
//				panic("mock out the LoadModuleVersion method")
//			},
//			LoadPackageFunc: func(ctx context.Context, id int64) (persister.Package, error) {
//				panic("mock out the LoadPackage method")
//			},
//			LoadPackageTypeFunc: func(ctx context.Context, id int64) (persister.PackageType, error) {
//				panic("mock out the LoadPackageType method")
//			},
//			LoadPackageVersionFunc: func(ctx context.Context, id int64) (persister.PackageVersion, error) {
//				panic("mock out the LoadPackageVersion method")
//			},
//			LoadProjectFunc: func(ctx context.Context, id int64) (persister.Project, error) {
//				panic("mock out the LoadProject method")
//			},
//			LoadProjectByNameFunc: func(ctx context.Context, name string) (persister.Project, error) {
//				panic("mock out the LoadProjectByName method")
//			},
//			LoadProjectByRepoURLFunc: func(ctx context.Context, repoUrl string) (persister.Project, error) {
//				panic("mock out the LoadProjectByRepoURL method")
//			},
//			LoadProjectRepoURLFunc: func(ctx context.Context, id int64) (string, error) {
//				panic("mock out the LoadProjectRepoURL method")
//			},
//			LoadSurveyFunc: func(ctx context.Context, id int64) (persister.Survey, error) {
//				panic("mock out the LoadSurvey method")
//			},
//			LoadSurveyByRepoURLFunc: func(ctx context.Context, repoUrl string) (persister.LoadSurveyByRepoURLRow, error) {
//				panic("mock out the LoadSurveyByRepoURL method")
//			},
//			LoadSurveyModuleFunc: func(ctx context.Context, id int64) (persister.SurveyModule, error) {
//				panic("mock out the LoadSurveyModule method")
//			},
//			LoadSymbolTypeFunc: func(ctx context.Context, id int64) (persister.SymbolType, error) {
//				panic("mock out the LoadSymbolType method")
//			},
//			LoadTypeFunc: func(ctx context.Context, id int64) (persister.Type, error) {
//				panic("mock out the LoadType method")
//			},
//			LoadVariableFunc: func(ctx context.Context, id int64) (persister.Variable, error) {
//				panic("mock out the LoadVariable method")
//			},
//			UpdateCategoryFunc: func(ctx context.Context, arg persister.UpdateCategoryParams) error {
//				panic("mock out the UpdateCategory method")
//			},
//			UpdateCodebaseFunc: func(ctx context.Context, arg persister.UpdateCodebaseParams) error {
//				panic("mock out the UpdateCodebase method")
//			},
//			UpdateCodebaseByProjectIdAndVersionTagFunc: func(ctx context.Context, arg persister.UpdateCodebaseByProjectIdAndVersionTagParams) error {
//				panic("mock out the UpdateCodebaseByProjectIdAndVersionTag method")
//			},
//			UpdateFileFunc: func(ctx context.Context, arg persister.UpdateFileParams) error {
//				panic("mock out the UpdateFile method")
//			},
//			UpdateImportFunc: func(ctx context.Context, arg persister.UpdateImportParams) error {
//				panic("mock out the UpdateImport method")
//			},
//			UpdateMethodFunc: func(ctx context.Context, arg persister.UpdateMethodParams) error {
//				panic("mock out the UpdateMethod method")
//			},
//			UpdateModuleFunc: func(ctx context.Context, arg persister.UpdateModuleParams) error {
//				panic("mock out the UpdateModule method")
//			},
//			UpdateModuleVersionFunc: func(ctx context.Context, arg persister.UpdateModuleVersionParams) error {
//				panic("mock out the UpdateModuleVersion method")
//			},
//			UpdatePackageFunc: func(ctx context.Context, arg persister.UpdatePackageParams) error {
//				panic("mock out the UpdatePackage method")
//			},
//			UpdatePackageTypeFunc: func(ctx context.Context, arg persister.UpdatePackageTypeParams) error {
//				panic("mock out the UpdatePackageType method")
//			},
//			UpdatePackageVersionFunc: func(ctx context.Context, arg persister.UpdatePackageVersionParams) error {
//				panic("mock out the UpdatePackageVersion method")
//			},
//			UpdateProjectFunc: func(ctx context.Context, arg persister.UpdateProjectParams) error {
//				panic("mock out the UpdateProject method")
//			},
//			UpdateProjectByNameFunc: func(ctx context.Context, arg persister.UpdateProjectByNameParams) error {
//				panic("mock out the UpdateProjectByName method")
//			},
//			UpdateSurveyModuleFunc: func(ctx context.Context, arg persister.UpdateSurveyModuleParams) error {
//				panic("mock out the UpdateSurveyModule method")
//			},
//			UpdateSymbolTypeFunc: func(ctx context.Context, arg persister.UpdateSymbolTypeParams) error {
//				panic("mock out the UpdateSymbolType method")
//			},
//			UpdateTypeFunc: func(ctx context.Context, arg persister.UpdateTypeParams) error {
//				panic("mock out the UpdateType method")
//			},
//			UpdateVariableFunc: func(ctx context.Context, arg persister.UpdateVariableParams) error {
//				panic("mock out the UpdateVariable method")
//			},
//			UpsertCategoryFunc: func(ctx context.Context, arg persister.UpsertCategoryParams) (persister.Category, error) {
//				panic("mock out the UpsertCategory method")
//			},
//			UpsertCodebaseFunc: func(ctx context.Context, arg persister.UpsertCodebaseParams) (persister.Codebase, error) {
//				panic("mock out the UpsertCodebase method")
//			},
//			UpsertFileFunc: func(ctx context.Context, arg persister.UpsertFileParams) (persister.File, error) {
//				panic("mock out the UpsertFile method")
//			},
//			UpsertImportFunc: func(ctx context.Context, arg persister.UpsertImportParams) (persister.Import, error) {
//				panic("mock out the UpsertImport method")
//			},
//			UpsertModuleFunc: func(ctx context.Context, name string) (persister.Module, error) {
//				panic("mock out the UpsertModule method")
//			},
//			UpsertModuleVersionFunc: func(ctx context.Context, arg persister.UpsertModuleVersionParams) (persister.ModuleVersion, error) {
//				panic("mock out the UpsertModuleVersion method")
//			},
//			UpsertPackageFunc: func(ctx context.Context, arg persister.UpsertPackageParams) (persister.Package, error) {
//				panic("mock out the UpsertPackage method")
//			},
//			UpsertPackageTypeFunc: func(ctx context.Context, arg persister.UpsertPackageTypeParams) (persister.PackageType, error) {
//				panic("mock out the UpsertPackageType method")
//			},
//			UpsertPackageVersionFunc: func(ctx context.Context, arg persister.UpsertPackageVersionParams) (persister.PackageVersion, error) {
//				panic("mock out the UpsertPackageVersion method")
//			},
//			UpsertProjectFunc: func(ctx context.Context, arg persister.UpsertProjectParams) (persister.Project, error) {
//				panic("mock out the UpsertProject method")
//			},
//			UpsertSurveyModuleFunc: func(ctx context.Context, arg persister.UpsertSurveyModuleParams) (persister.SurveyModule, error) {
//				panic("mock out the UpsertSurveyModule method")
//			},
//			UpsertSymbolTypeFunc: func(ctx context.Context, arg persister.UpsertSymbolTypeParams) (persister.SymbolType, error) {
//				panic("mock out the UpsertSymbolType method")
//			},
//			WithTxFunc: func(tx *sql.Tx) *persister.Queries {
//				panic("mock out the WithTx method")
//			},
//		}
//
//		// use mockedDataStoreQueries in code that requires persister.DataStoreQueries
//		// and then make assertions.
//
//	}
type DataStoreQueriesStub struct {
	// DeleteCategoryFunc mocks the DeleteCategory method.
	DeleteCategoryFunc func(ctx context.Context, id int64) error

	// DeleteCodebaseFunc mocks the DeleteCodebase method.
	DeleteCodebaseFunc func(ctx context.Context, id int64) error

	// DeleteCodebaseByProjectIdAndVersionTagFunc mocks the DeleteCodebaseByProjectIdAndVersionTag method.
	DeleteCodebaseByProjectIdAndVersionTagFunc func(ctx context.Context, arg persister.DeleteCodebaseByProjectIdAndVersionTagParams) error

	// DeleteCodebaseSurveysFunc mocks the DeleteCodebaseSurveys method.
	DeleteCodebaseSurveysFunc func(ctx context.Context, codebaseID int64) error

	// DeleteFileFunc mocks the DeleteFile method.
	DeleteFileFunc func(ctx context.Context, id int64) error

	// DeleteImportFunc mocks the DeleteImport method.
	DeleteImportFunc func(ctx context.Context, id int64) error

	// DeleteMethodFunc mocks the DeleteMethod method.
	DeleteMethodFunc func(ctx context.Context, id int64) error

	// DeleteModuleFunc mocks the DeleteModule method.
	DeleteModuleFunc func(ctx context.Context, id int64) error

	// DeleteModuleVersionFunc mocks the DeleteModuleVersion method.
	DeleteModuleVersionFunc func(ctx context.Context, id int64) error

	// DeletePackageFunc mocks the DeletePackage method.
	DeletePackageFunc func(ctx context.Context, id int64) error

	// DeletePackageTypeFunc mocks the DeletePackageType method.
	DeletePackageTypeFunc func(ctx context.Context, id int64) error

	// DeletePackageVersionFunc mocks the DeletePackageVersion method.
	DeletePackageVersionFunc func(ctx context.Context, id int64) error

	// DeleteProjectFunc mocks the DeleteProject method.
	DeleteProjectFunc func(ctx context.Context, id int64) error

	// DeleteProjectByNameFunc mocks the DeleteProjectByName method.
	DeleteProjectByNameFunc func(ctx context.Context, name string) error

	// DeleteSurveyFunc mocks the DeleteSurvey method.
	DeleteSurveyFunc func(ctx context.Context, id int64) error

	// DeleteSurveyModuleFunc mocks the DeleteSurveyModule method.
	DeleteSurveyModuleFunc func(ctx context.Context, id int64) error

	// DeleteSymbolTypeFunc mocks the DeleteSymbolType method.
	DeleteSymbolTypeFunc func(ctx context.Context, id int64) error

	// DeleteTypeFunc mocks the DeleteType method.
	DeleteTypeFunc func(ctx context.Context, id int64) error

	// DeleteVariableFunc mocks the DeleteVariable method.
	DeleteVariableFunc func(ctx context.Context, id int64) error

	// InsertCategoryFunc mocks the InsertCategory method.
	InsertCategoryFunc func(ctx context.Context, arg persister.InsertCategoryParams) (persister.Category, error)

	// InsertCodebaseFunc mocks the InsertCodebase method.
	InsertCodebaseFunc func(ctx context.Context, arg persister.InsertCodebaseParams) (persister.Codebase, error)

	// InsertFileFunc mocks the InsertFile method.
	InsertFileFunc func(ctx context.Context, arg persister.InsertFileParams) (persister.File, error)

	// InsertImportFunc mocks the InsertImport method.
	InsertImportFunc func(ctx context.Context, arg persister.InsertImportParams) (persister.Import, error)

	// InsertMethodFunc mocks the InsertMethod method.
	InsertMethodFunc func(ctx context.Context, arg persister.InsertMethodParams) (persister.Method, error)

	// InsertModuleFunc mocks the InsertModule method.
	InsertModuleFunc func(ctx context.Context, name string) (persister.Module, error)

	// InsertModuleVersionFunc mocks the InsertModuleVersion method.
	InsertModuleVersionFunc func(ctx context.Context, arg persister.InsertModuleVersionParams) (persister.ModuleVersion, error)

	// InsertPackageFunc mocks the InsertPackage method.
	InsertPackageFunc func(ctx context.Context, arg persister.InsertPackageParams) (persister.Package, error)

	// InsertPackageTypeFunc mocks the InsertPackageType method.
	InsertPackageTypeFunc func(ctx context.Context, arg persister.InsertPackageTypeParams) (persister.PackageType, error)

	// InsertPackageVersionFunc mocks the InsertPackageVersion method.
	InsertPackageVersionFunc func(ctx context.Context, arg persister.InsertPackageVersionParams) (persister.PackageVersion, error)

	// InsertProjectFunc mocks the InsertProject method.
	InsertProjectFunc func(ctx context.Context, arg persister.InsertProjectParams) (persister.Project, error)

	// InsertSurveyFunc mocks the InsertSurvey method.
	InsertSurveyFunc func(ctx context.Context, arg persister.InsertSurveyParams) (persister.Survey, error)

	// InsertSurveyModuleFunc mocks the InsertSurveyModule method.
	InsertSurveyModuleFunc func(ctx context.Context, arg persister.InsertSurveyModuleParams) (persister.SurveyModule, error)

	// InsertSymbolTypeFunc mocks the InsertSymbolType method.
	InsertSymbolTypeFunc func(ctx context.Context, arg persister.InsertSymbolTypeParams) (persister.SymbolType, error)

	// InsertTypeFunc mocks the InsertType method.
	InsertTypeFunc func(ctx context.Context, arg persister.InsertTypeParams) (persister.Type, error)

	// InsertVariableFunc mocks the InsertVariable method.
	InsertVariableFunc func(ctx context.Context, arg persister.InsertVariableParams) (persister.Variable, error)

	// ListCategoriesFunc mocks the ListCategories method.
	ListCategoriesFunc func(ctx context.Context) ([]persister.Category, error)

	// ListCodebaseSurveysFunc mocks the ListCodebaseSurveys method.
	ListCodebaseSurveysFunc func(ctx context.Context, codebaseID int64) ([]persister.Survey, error)

	// ListCodebasesFunc mocks the ListCodebases method.
	ListCodebasesFunc func(ctx context.Context) ([]persister.Codebase, error)

	// ListFilesFunc mocks the ListFiles method.
	ListFilesFunc func(ctx context.Context) ([]persister.File, error)

	// ListFilesBySurveyFunc mocks the ListFilesBySurvey method.
	ListFilesBySurveyFunc func(ctx context.Context, surveyID int64) ([]persister.File, error)

	// ListImportsFunc mocks the ListImports method.
	ListImportsFunc func(ctx context.Context) ([]persister.Import, error)

	// ListMethodsFunc mocks the ListMethods method.
	ListMethodsFunc func(ctx context.Context) ([]persister.Method, error)

	// ListModuleVersionsFunc mocks the ListModuleVersions method.
	ListModuleVersionsFunc func(ctx context.Context) ([]persister.ModuleVersion, error)

	// ListModulesFunc mocks the ListModules method.
	ListModulesFunc func(ctx context.Context) ([]persister.Module, error)

	// ListPackageTypesFunc mocks the ListPackageTypes method.
	ListPackageTypesFunc func(ctx context.Context) ([]persister.PackageType, error)

	// ListPackageTypesByNameFunc mocks the ListPackageTypesByName method.
	ListPackageTypesByNameFunc func(ctx context.Context) ([]persister.PackageType, error)

	// ListPackageVersionsFunc mocks the ListPackageVersions method.
	ListPackageVersionsFunc func(ctx context.Context) ([]persister.PackageVersion, error)

	// ListPackagesFunc mocks the ListPackages method.
	ListPackagesFunc func(ctx context.Context) ([]persister.Package, error)

	// ListProjectsFunc mocks the ListProjects method.
	ListProjectsFunc func(ctx context.Context) ([]persister.Project, error)

	// ListSurveyModulesFunc mocks the ListSurveyModules method.
	ListSurveyModulesFunc func(ctx context.Context) ([]persister.SurveyModule, error)

	// ListSurveysFunc mocks the ListSurveys method.
	ListSurveysFunc func(ctx context.Context) ([]persister.ListSurveysRow, error)

	// ListSymbolTypesFunc mocks the ListSymbolTypes method.
	ListSymbolTypesFunc func(ctx context.Context) ([]persister.SymbolType, error)

	// ListSymbolTypesByNameFunc mocks the ListSymbolTypesByName method.
	ListSymbolTypesByNameFunc func(ctx context.Context) ([]persister.SymbolType, error)

	// ListTypesFunc mocks the ListTypes method.
	ListTypesFunc func(ctx context.Context) ([]persister.TypeView, error)

	// ListTypesByFileFunc mocks the ListTypesByFile method.
	ListTypesByFileFunc func(ctx context.Context, fileID int64) ([]persister.TypeView, error)

	// ListTypesBySurveyFunc mocks the ListTypesBySurvey method.
	ListTypesBySurveyFunc func(ctx context.Context, surveyID int64) ([]persister.TypeView, error)

	// ListVariablesFunc mocks the ListVariables method.
	ListVariablesFunc func(ctx context.Context) ([]persister.Variable, error)

	// LoadCategoryFunc mocks the LoadCategory method.
	LoadCategoryFunc func(ctx context.Context, id int64) (persister.Category, error)

	// LoadCodebaseFunc mocks the LoadCodebase method.
	LoadCodebaseFunc func(ctx context.Context, id int64) (persister.Codebase, error)

	// LoadCodebaseIDByProjectAndVersionFunc mocks the LoadCodebaseIDByProjectAndVersion method.
	LoadCodebaseIDByProjectAndVersionFunc func(ctx context.Context, arg persister.LoadCodebaseIDByProjectAndVersionParams) (int64, error)

	// LoadCodebaseIdByRepoURLFunc mocks the LoadCodebaseIdByRepoURL method.
	LoadCodebaseIdByRepoURLFunc func(ctx context.Context, repoUrl string) (int64, error)

	// LoadFileFunc mocks the LoadFile method.
	LoadFileFunc func(ctx context.Context, id int64) (persister.File, error)

	// LoadImportFunc mocks the LoadImport method.
	LoadImportFunc func(ctx context.Context, id int64) (persister.Import, error)

	// LoadMethodFunc mocks the LoadMethod method.
	LoadMethodFunc func(ctx context.Context, id int64) (persister.Method, error)

	// LoadModuleFunc mocks the LoadModule method.
	LoadModuleFunc func(ctx context.Context, id int64) (persister.Module, error)

	// LoadModuleVersionFunc mocks the LoadModuleVersion method.
	LoadModuleVersionFunc func(ctx context.Context, id int64) (persister.ModuleVersion, error)

	// LoadPackageFunc mocks the LoadPackage method.
	LoadPackageFunc func(ctx context.Context, id int64) (persister.Package, error)

	// LoadPackageTypeFunc mocks the LoadPackageType method.
	LoadPackageTypeFunc func(ctx context.Context, id int64) (persister.PackageType, error)

	// LoadPackageVersionFunc mocks the LoadPackageVersion method.
	LoadPackageVersionFunc func(ctx context.Context, id int64) (persister.PackageVersion, error)

	// LoadProjectFunc mocks the LoadProject method.
	LoadProjectFunc func(ctx context.Context, id int64) (persister.Project, error)

	// LoadProjectByNameFunc mocks the LoadProjectByName method.
	LoadProjectByNameFunc func(ctx context.Context, name string) (persister.Project, error)

	// LoadProjectByRepoURLFunc mocks the LoadProjectByRepoURL method.
	LoadProjectByRepoURLFunc func(ctx context.Context, repoUrl string) (persister.Project, error)

	// LoadProjectRepoURLFunc mocks the LoadProjectRepoURL method.
	LoadProjectRepoURLFunc func(ctx context.Context, id int64) (string, error)

	// LoadSurveyFunc mocks the LoadSurvey method.
	LoadSurveyFunc func(ctx context.Context, id int64) (persister.Survey, error)

	// LoadSurveyByRepoURLFunc mocks the LoadSurveyByRepoURL method.
	LoadSurveyByRepoURLFunc func(ctx context.Context, repoUrl string) (persister.LoadSurveyByRepoURLRow, error)

	// LoadSurveyModuleFunc mocks the LoadSurveyModule method.
	LoadSurveyModuleFunc func(ctx context.Context, id int64) (persister.SurveyModule, error)

	// LoadSymbolTypeFunc mocks the LoadSymbolType method.
	LoadSymbolTypeFunc func(ctx context.Context, id int64) (persister.SymbolType, error)

	// LoadTypeFunc mocks the LoadType method.
	LoadTypeFunc func(ctx context.Context, id int64) (persister.Type, error)

	// LoadVariableFunc mocks the LoadVariable method.
	LoadVariableFunc func(ctx context.Context, id int64) (persister.Variable, error)

	// UpdateCategoryFunc mocks the UpdateCategory method.
	UpdateCategoryFunc func(ctx context.Context, arg persister.UpdateCategoryParams) error

	// UpdateCodebaseFunc mocks the UpdateCodebase method.
	UpdateCodebaseFunc func(ctx context.Context, arg persister.UpdateCodebaseParams) error

	// UpdateCodebaseByProjectIdAndVersionTagFunc mocks the UpdateCodebaseByProjectIdAndVersionTag method.
	UpdateCodebaseByProjectIdAndVersionTagFunc func(ctx context.Context, arg persister.UpdateCodebaseByProjectIdAndVersionTagParams) error

	// UpdateFileFunc mocks the UpdateFile method.
	UpdateFileFunc func(ctx context.Context, arg persister.UpdateFileParams) error

	// UpdateImportFunc mocks the UpdateImport method.
	UpdateImportFunc func(ctx context.Context, arg persister.UpdateImportParams) error

	// UpdateMethodFunc mocks the UpdateMethod method.
	UpdateMethodFunc func(ctx context.Context, arg persister.UpdateMethodParams) error

	// UpdateModuleFunc mocks the UpdateModule method.
	UpdateModuleFunc func(ctx context.Context, arg persister.UpdateModuleParams) error

	// UpdateModuleVersionFunc mocks the UpdateModuleVersion method.
	UpdateModuleVersionFunc func(ctx context.Context, arg persister.UpdateModuleVersionParams) error

	// UpdatePackageFunc mocks the UpdatePackage method.
	UpdatePackageFunc func(ctx context.Context, arg persister.UpdatePackageParams) error

	// UpdatePackageTypeFunc mocks the UpdatePackageType method.
	UpdatePackageTypeFunc func(ctx context.Context, arg persister.UpdatePackageTypeParams) error

	// UpdatePackageVersionFunc mocks the UpdatePackageVersion method.
	UpdatePackageVersionFunc func(ctx context.Context, arg persister.UpdatePackageVersionParams) error

	// UpdateProjectFunc mocks the UpdateProject method.
	UpdateProjectFunc func(ctx context.Context, arg persister.UpdateProjectParams) error

	// UpdateProjectByNameFunc mocks the UpdateProjectByName method.
	UpdateProjectByNameFunc func(ctx context.Context, arg persister.UpdateProjectByNameParams) error

	// UpdateSurveyModuleFunc mocks the UpdateSurveyModule method.
	UpdateSurveyModuleFunc func(ctx context.Context, arg persister.UpdateSurveyModuleParams) error

	// UpdateSymbolTypeFunc mocks the UpdateSymbolType method.
	UpdateSymbolTypeFunc func(ctx context.Context, arg persister.UpdateSymbolTypeParams) error

	// UpdateTypeFunc mocks the UpdateType method.
	UpdateTypeFunc func(ctx context.Context, arg persister.UpdateTypeParams) error

	// UpdateVariableFunc mocks the UpdateVariable method.
	UpdateVariableFunc func(ctx context.Context, arg persister.UpdateVariableParams) error

	// UpsertCategoryFunc mocks the UpsertCategory method.
	UpsertCategoryFunc func(ctx context.Context, arg persister.UpsertCategoryParams) (persister.Category, error)

	// UpsertCodebaseFunc mocks the UpsertCodebase method.
	UpsertCodebaseFunc func(ctx context.Context, arg persister.UpsertCodebaseParams) (persister.Codebase, error)

	// UpsertFileFunc mocks the UpsertFile method.
	UpsertFileFunc func(ctx context.Context, arg persister.UpsertFileParams) (persister.File, error)

	// UpsertImportFunc mocks the UpsertImport method.
	UpsertImportFunc func(ctx context.Context, arg persister.UpsertImportParams) (persister.Import, error)

	// UpsertModuleFunc mocks the UpsertModule method.
	UpsertModuleFunc func(ctx context.Context, name string) (persister.Module, error)

	// UpsertModuleVersionFunc mocks the UpsertModuleVersion method.
	UpsertModuleVersionFunc func(ctx context.Context, arg persister.UpsertModuleVersionParams) (persister.ModuleVersion, error)

	// UpsertPackageFunc mocks the UpsertPackage method.
	UpsertPackageFunc func(ctx context.Context, arg persister.UpsertPackageParams) (persister.Package, error)

	// UpsertPackageTypeFunc mocks the UpsertPackageType method.
	UpsertPackageTypeFunc func(ctx context.Context, arg persister.UpsertPackageTypeParams) (persister.PackageType, error)

	// UpsertPackageVersionFunc mocks the UpsertPackageVersion method.
	UpsertPackageVersionFunc func(ctx context.Context, arg persister.UpsertPackageVersionParams) (persister.PackageVersion, error)

	// UpsertProjectFunc mocks the UpsertProject method.
	UpsertProjectFunc func(ctx context.Context, arg persister.UpsertProjectParams) (persister.Project, error)

	// UpsertSurveyModuleFunc mocks the UpsertSurveyModule method.
	UpsertSurveyModuleFunc func(ctx context.Context, arg persister.UpsertSurveyModuleParams) (persister.SurveyModule, error)

	// UpsertSymbolTypeFunc mocks the UpsertSymbolType method.
	UpsertSymbolTypeFunc func(ctx context.Context, arg persister.UpsertSymbolTypeParams) (persister.SymbolType, error)

	// WithTxFunc mocks the WithTx method.
	WithTxFunc func(tx *sql.Tx) *persister.Queries

	// calls tracks calls to the methods.
	calls struct {
		// DeleteCategory holds details about calls to the DeleteCategory method.
		DeleteCategory []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// DeleteCodebase holds details about calls to the DeleteCodebase method.
		DeleteCodebase []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// DeleteCodebaseByProjectIdAndVersionTag holds details about calls to the DeleteCodebaseByProjectIdAndVersionTag method.
		DeleteCodebaseByProjectIdAndVersionTag []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.DeleteCodebaseByProjectIdAndVersionTagParams
		}
		// DeleteCodebaseSurveys holds details about calls to the DeleteCodebaseSurveys method.
		DeleteCodebaseSurveys []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CodebaseID is the codebaseID argument value.
			CodebaseID int64
		}
		// DeleteFile holds details about calls to the DeleteFile method.
		DeleteFile []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// DeleteImport holds details about calls to the DeleteImport method.
		DeleteImport []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// DeleteMethod holds details about calls to the DeleteMethod method.
		DeleteMethod []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// DeleteModule holds details about calls to the DeleteModule method.
		DeleteModule []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// DeleteModuleVersion holds details about calls to the DeleteModuleVersion method.
		DeleteModuleVersion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// DeletePackage holds details about calls to the DeletePackage method.
		DeletePackage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// DeletePackageType holds details about calls to the DeletePackageType method.
		DeletePackageType []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// DeletePackageVersion holds details about calls to the DeletePackageVersion method.
		DeletePackageVersion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// DeleteProject holds details about calls to the DeleteProject method.
		DeleteProject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// DeleteProjectByName holds details about calls to the DeleteProjectByName method.
		DeleteProjectByName []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
		// DeleteSurvey holds details about calls to the DeleteSurvey method.
		DeleteSurvey []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// DeleteSurveyModule holds details about calls to the DeleteSurveyModule method.
		DeleteSurveyModule []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// DeleteSymbolType holds details about calls to the DeleteSymbolType method.
		DeleteSymbolType []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// DeleteType holds details about calls to the DeleteType method.
		DeleteType []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// DeleteVariable holds details about calls to the DeleteVariable method.
		DeleteVariable []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// InsertCategory holds details about calls to the InsertCategory method.
		InsertCategory []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.InsertCategoryParams
		}
		// InsertCodebase holds details about calls to the InsertCodebase method.
		InsertCodebase []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.InsertCodebaseParams
		}
		// InsertFile holds details about calls to the InsertFile method.
		InsertFile []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.InsertFileParams
		}
		// InsertImport holds details about calls to the InsertImport method.
		InsertImport []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.InsertImportParams
		}
		// InsertMethod holds details about calls to the InsertMethod method.
		InsertMethod []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.InsertMethodParams
		}
		// InsertModule holds details about calls to the InsertModule method.
		InsertModule []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
		// InsertModuleVersion holds details about calls to the InsertModuleVersion method.
		InsertModuleVersion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.InsertModuleVersionParams
		}
		// InsertPackage holds details about calls to the InsertPackage method.
		InsertPackage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.InsertPackageParams
		}
		// InsertPackageType holds details about calls to the InsertPackageType method.
		InsertPackageType []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.InsertPackageTypeParams
		}
		// InsertPackageVersion holds details about calls to the InsertPackageVersion method.
		InsertPackageVersion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.InsertPackageVersionParams
		}
		// InsertProject holds details about calls to the InsertProject method.
		InsertProject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.InsertProjectParams
		}
		// InsertSurvey holds details about calls to the InsertSurvey method.
		InsertSurvey []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.InsertSurveyParams
		}
		// InsertSurveyModule holds details about calls to the InsertSurveyModule method.
		InsertSurveyModule []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.InsertSurveyModuleParams
		}
		// InsertSymbolType holds details about calls to the InsertSymbolType method.
		InsertSymbolType []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.InsertSymbolTypeParams
		}
		// InsertType holds details about calls to the InsertType method.
		InsertType []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.InsertTypeParams
		}
		// InsertVariable holds details about calls to the InsertVariable method.
		InsertVariable []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.InsertVariableParams
		}
		// ListCategories holds details about calls to the ListCategories method.
		ListCategories []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListCodebaseSurveys holds details about calls to the ListCodebaseSurveys method.
		ListCodebaseSurveys []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// CodebaseID is the codebaseID argument value.
			CodebaseID int64
		}
		// ListCodebases holds details about calls to the ListCodebases method.
		ListCodebases []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListFiles holds details about calls to the ListFiles method.
		ListFiles []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListFilesBySurvey holds details about calls to the ListFilesBySurvey method.
		ListFilesBySurvey []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SurveyID is the surveyID argument value.
			SurveyID int64
		}
		// ListImports holds details about calls to the ListImports method.
		ListImports []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListMethods holds details about calls to the ListMethods method.
		ListMethods []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListModuleVersions holds details about calls to the ListModuleVersions method.
		ListModuleVersions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListModules holds details about calls to the ListModules method.
		ListModules []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListPackageTypes holds details about calls to the ListPackageTypes method.
		ListPackageTypes []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListPackageTypesByName holds details about calls to the ListPackageTypesByName method.
		ListPackageTypesByName []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListPackageVersions holds details about calls to the ListPackageVersions method.
		ListPackageVersions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListPackages holds details about calls to the ListPackages method.
		ListPackages []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListProjects holds details about calls to the ListProjects method.
		ListProjects []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListSurveyModules holds details about calls to the ListSurveyModules method.
		ListSurveyModules []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListSurveys holds details about calls to the ListSurveys method.
		ListSurveys []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListSymbolTypes holds details about calls to the ListSymbolTypes method.
		ListSymbolTypes []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListSymbolTypesByName holds details about calls to the ListSymbolTypesByName method.
		ListSymbolTypesByName []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListTypes holds details about calls to the ListTypes method.
		ListTypes []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListTypesByFile holds details about calls to the ListTypesByFile method.
		ListTypesByFile []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FileID is the fileID argument value.
			FileID int64
		}
		// ListTypesBySurvey holds details about calls to the ListTypesBySurvey method.
		ListTypesBySurvey []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SurveyID is the surveyID argument value.
			SurveyID int64
		}
		// ListVariables holds details about calls to the ListVariables method.
		ListVariables []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// LoadCategory holds details about calls to the LoadCategory method.
		LoadCategory []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// LoadCodebase holds details about calls to the LoadCodebase method.
		LoadCodebase []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// LoadCodebaseIDByProjectAndVersion holds details about calls to the LoadCodebaseIDByProjectAndVersion method.
		LoadCodebaseIDByProjectAndVersion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.LoadCodebaseIDByProjectAndVersionParams
		}
		// LoadCodebaseIdByRepoURL holds details about calls to the LoadCodebaseIdByRepoURL method.
		LoadCodebaseIdByRepoURL []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RepoUrl is the repoUrl argument value.
			RepoUrl string
		}
		// LoadFile holds details about calls to the LoadFile method.
		LoadFile []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// LoadImport holds details about calls to the LoadImport method.
		LoadImport []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// LoadMethod holds details about calls to the LoadMethod method.
		LoadMethod []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// LoadModule holds details about calls to the LoadModule method.
		LoadModule []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// LoadModuleVersion holds details about calls to the LoadModuleVersion method.
		LoadModuleVersion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// LoadPackage holds details about calls to the LoadPackage method.
		LoadPackage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// LoadPackageType holds details about calls to the LoadPackageType method.
		LoadPackageType []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// LoadPackageVersion holds details about calls to the LoadPackageVersion method.
		LoadPackageVersion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// LoadProject holds details about calls to the LoadProject method.
		LoadProject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// LoadProjectByName holds details about calls to the LoadProjectByName method.
		LoadProjectByName []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
		// LoadProjectByRepoURL holds details about calls to the LoadProjectByRepoURL method.
		LoadProjectByRepoURL []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RepoUrl is the repoUrl argument value.
			RepoUrl string
		}
		// LoadProjectRepoURL holds details about calls to the LoadProjectRepoURL method.
		LoadProjectRepoURL []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// LoadSurvey holds details about calls to the LoadSurvey method.
		LoadSurvey []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// LoadSurveyByRepoURL holds details about calls to the LoadSurveyByRepoURL method.
		LoadSurveyByRepoURL []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RepoUrl is the repoUrl argument value.
			RepoUrl string
		}
		// LoadSurveyModule holds details about calls to the LoadSurveyModule method.
		LoadSurveyModule []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// LoadSymbolType holds details about calls to the LoadSymbolType method.
		LoadSymbolType []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// LoadType holds details about calls to the LoadType method.
		LoadType []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// LoadVariable holds details about calls to the LoadVariable method.
		LoadVariable []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// UpdateCategory holds details about calls to the UpdateCategory method.
		UpdateCategory []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpdateCategoryParams
		}
		// UpdateCodebase holds details about calls to the UpdateCodebase method.
		UpdateCodebase []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpdateCodebaseParams
		}
		// UpdateCodebaseByProjectIdAndVersionTag holds details about calls to the UpdateCodebaseByProjectIdAndVersionTag method.
		UpdateCodebaseByProjectIdAndVersionTag []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpdateCodebaseByProjectIdAndVersionTagParams
		}
		// UpdateFile holds details about calls to the UpdateFile method.
		UpdateFile []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpdateFileParams
		}
		// UpdateImport holds details about calls to the UpdateImport method.
		UpdateImport []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpdateImportParams
		}
		// UpdateMethod holds details about calls to the UpdateMethod method.
		UpdateMethod []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpdateMethodParams
		}
		// UpdateModule holds details about calls to the UpdateModule method.
		UpdateModule []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpdateModuleParams
		}
		// UpdateModuleVersion holds details about calls to the UpdateModuleVersion method.
		UpdateModuleVersion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpdateModuleVersionParams
		}
		// UpdatePackage holds details about calls to the UpdatePackage method.
		UpdatePackage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpdatePackageParams
		}
		// UpdatePackageType holds details about calls to the UpdatePackageType method.
		UpdatePackageType []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpdatePackageTypeParams
		}
		// UpdatePackageVersion holds details about calls to the UpdatePackageVersion method.
		UpdatePackageVersion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpdatePackageVersionParams
		}
		// UpdateProject holds details about calls to the UpdateProject method.
		UpdateProject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpdateProjectParams
		}
		// UpdateProjectByName holds details about calls to the UpdateProjectByName method.
		UpdateProjectByName []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpdateProjectByNameParams
		}
		// UpdateSurveyModule holds details about calls to the UpdateSurveyModule method.
		UpdateSurveyModule []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpdateSurveyModuleParams
		}
		// UpdateSymbolType holds details about calls to the UpdateSymbolType method.
		UpdateSymbolType []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpdateSymbolTypeParams
		}
		// UpdateType holds details about calls to the UpdateType method.
		UpdateType []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpdateTypeParams
		}
		// UpdateVariable holds details about calls to the UpdateVariable method.
		UpdateVariable []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpdateVariableParams
		}
		// UpsertCategory holds details about calls to the UpsertCategory method.
		UpsertCategory []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpsertCategoryParams
		}
		// UpsertCodebase holds details about calls to the UpsertCodebase method.
		UpsertCodebase []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpsertCodebaseParams
		}
		// UpsertFile holds details about calls to the UpsertFile method.
		UpsertFile []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpsertFileParams
		}
		// UpsertImport holds details about calls to the UpsertImport method.
		UpsertImport []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpsertImportParams
		}
		// UpsertModule holds details about calls to the UpsertModule method.
		UpsertModule []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
		// UpsertModuleVersion holds details about calls to the UpsertModuleVersion method.
		UpsertModuleVersion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpsertModuleVersionParams
		}
		// UpsertPackage holds details about calls to the UpsertPackage method.
		UpsertPackage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpsertPackageParams
		}
		// UpsertPackageType holds details about calls to the UpsertPackageType method.
		UpsertPackageType []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpsertPackageTypeParams
		}
		// UpsertPackageVersion holds details about calls to the UpsertPackageVersion method.
		UpsertPackageVersion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpsertPackageVersionParams
		}
		// UpsertProject holds details about calls to the UpsertProject method.
		UpsertProject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpsertProjectParams
		}
		// UpsertSurveyModule holds details about calls to the UpsertSurveyModule method.
		UpsertSurveyModule []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpsertSurveyModuleParams
		}
		// UpsertSymbolType holds details about calls to the UpsertSymbolType method.
		UpsertSymbolType []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg persister.UpsertSymbolTypeParams
		}
		// WithTx holds details about calls to the WithTx method.
		WithTx []struct {
			// Tx is the tx argument value.
			Tx *sql.Tx
		}
	}
	lockDeleteCategory                         sync.RWMutex
	lockDeleteCodebase                         sync.RWMutex
	lockDeleteCodebaseByProjectIdAndVersionTag sync.RWMutex
	lockDeleteCodebaseSurveys                  sync.RWMutex
	lockDeleteFile                             sync.RWMutex
	lockDeleteImport                           sync.RWMutex
	lockDeleteMethod                           sync.RWMutex
	lockDeleteModule                           sync.RWMutex
	lockDeleteModuleVersion                    sync.RWMutex
	lockDeletePackage                          sync.RWMutex
	lockDeletePackageType                      sync.RWMutex
	lockDeletePackageVersion                   sync.RWMutex
	lockDeleteProject                          sync.RWMutex
	lockDeleteProjectByName                    sync.RWMutex
	lockDeleteSurvey                           sync.RWMutex
	lockDeleteSurveyModule                     sync.RWMutex
	lockDeleteSymbolType                       sync.RWMutex
	lockDeleteType                             sync.RWMutex
	lockDeleteVariable                         sync.RWMutex
	lockInsertCategory                         sync.RWMutex
	lockInsertCodebase                         sync.RWMutex
	lockInsertFile                             sync.RWMutex
	lockInsertImport                           sync.RWMutex
	lockInsertMethod                           sync.RWMutex
	lockInsertModule                           sync.RWMutex
	lockInsertModuleVersion                    sync.RWMutex
	lockInsertPackage                          sync.RWMutex
	lockInsertPackageType                      sync.RWMutex
	lockInsertPackageVersion                   sync.RWMutex
	lockInsertProject                          sync.RWMutex
	lockInsertSurvey                           sync.RWMutex
	lockInsertSurveyModule                     sync.RWMutex
	lockInsertSymbolType                       sync.RWMutex
	lockInsertType                             sync.RWMutex
	lockInsertVariable                         sync.RWMutex
	lockListCategories                         sync.RWMutex
	lockListCodebaseSurveys                    sync.RWMutex
	lockListCodebases                          sync.RWMutex
	lockListFiles                              sync.RWMutex
	lockListFilesBySurvey                      sync.RWMutex
	lockListImports                            sync.RWMutex
	lockListMethods                            sync.RWMutex
	lockListModuleVersions                     sync.RWMutex
	lockListModules                            sync.RWMutex
	lockListPackageTypes                       sync.RWMutex
	lockListPackageTypesByName                 sync.RWMutex
	lockListPackageVersions                    sync.RWMutex
	lockListPackages                           sync.RWMutex
	lockListProjects                           sync.RWMutex
	lockListSurveyModules                      sync.RWMutex
	lockListSurveys                            sync.RWMutex
	lockListSymbolTypes                        sync.RWMutex
	lockListSymbolTypesByName                  sync.RWMutex
	lockListTypes                              sync.RWMutex
	lockListTypesByFile                        sync.RWMutex
	lockListTypesBySurvey                      sync.RWMutex
	lockListVariables                          sync.RWMutex
	lockLoadCategory                           sync.RWMutex
	lockLoadCodebase                           sync.RWMutex
	lockLoadCodebaseIDByProjectAndVersion      sync.RWMutex
	lockLoadCodebaseIdByRepoURL                sync.RWMutex
	lockLoadFile                               sync.RWMutex
	lockLoadImport                             sync.RWMutex
	lockLoadMethod                             sync.RWMutex
	lockLoadModule                             sync.RWMutex
	lockLoadModuleVersion                      sync.RWMutex
	lockLoadPackage                            sync.RWMutex
	lockLoadPackageType                        sync.RWMutex
	lockLoadPackageVersion                     sync.RWMutex
	lockLoadProject                            sync.RWMutex
	lockLoadProjectByName                      sync.RWMutex
	lockLoadProjectByRepoURL                   sync.RWMutex
	lockLoadProjectRepoURL                     sync.RWMutex
	lockLoadSurvey                             sync.RWMutex
	lockLoadSurveyByRepoURL                    sync.RWMutex
	lockLoadSurveyModule                       sync.RWMutex
	lockLoadSymbolType                         sync.RWMutex
	lockLoadType                               sync.RWMutex
	lockLoadVariable                           sync.RWMutex
	lockUpdateCategory                         sync.RWMutex
	lockUpdateCodebase                         sync.RWMutex
	lockUpdateCodebaseByProjectIdAndVersionTag sync.RWMutex
	lockUpdateFile                             sync.RWMutex
	lockUpdateImport                           sync.RWMutex
	lockUpdateMethod                           sync.RWMutex
	lockUpdateModule                           sync.RWMutex
	lockUpdateModuleVersion                    sync.RWMutex
	lockUpdatePackage                          sync.RWMutex
	lockUpdatePackageType                      sync.RWMutex
	lockUpdatePackageVersion                   sync.RWMutex
	lockUpdateProject                          sync.RWMutex
	lockUpdateProjectByName                    sync.RWMutex
	lockUpdateSurveyModule                     sync.RWMutex
	lockUpdateSymbolType                       sync.RWMutex
	lockUpdateType                             sync.RWMutex
	lockUpdateVariable                         sync.RWMutex
	lockUpsertCategory                         sync.RWMutex
	lockUpsertCodebase                         sync.RWMutex
	lockUpsertFile                             sync.RWMutex
	lockUpsertImport                           sync.RWMutex
	lockUpsertModule                           sync.RWMutex
	lockUpsertModuleVersion                    sync.RWMutex
	lockUpsertPackage                          sync.RWMutex
	lockUpsertPackageType                      sync.RWMutex
	lockUpsertPackageVersion                   sync.RWMutex
	lockUpsertProject                          sync.RWMutex
	lockUpsertSurveyModule                     sync.RWMutex
	lockUpsertSymbolType                       sync.RWMutex
	lockWithTx                                 sync.RWMutex
}

// DeleteCategory calls DeleteCategoryFunc.
func (mock *DataStoreQueriesStub) DeleteCategory(ctx context.Context, id int64) error {
	if mock.DeleteCategoryFunc == nil {
		panic("DataStoreQueriesStub.DeleteCategoryFunc: method is nil but DataStoreQueries.DeleteCategory was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteCategory.Lock()
	mock.calls.DeleteCategory = append(mock.calls.DeleteCategory, callInfo)
	mock.lockDeleteCategory.Unlock()
	return mock.DeleteCategoryFunc(ctx, id)
}

// DeleteCategoryCalls gets all the calls that were made to DeleteCategory.
// Check the length with:
//
//	len(mockedDataStoreQueries.DeleteCategoryCalls())
func (mock *DataStoreQueriesStub) DeleteCategoryCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockDeleteCategory.RLock()
	calls = mock.calls.DeleteCategory
	mock.lockDeleteCategory.RUnlock()
	return calls
}

// ResetDeleteCategoryCalls reset all the calls that were made to DeleteCategory.
func (mock *DataStoreQueriesStub) ResetDeleteCategoryCalls() {
	mock.lockDeleteCategory.Lock()
	mock.calls.DeleteCategory = nil
	mock.lockDeleteCategory.Unlock()
}

// DeleteCodebase calls DeleteCodebaseFunc.
func (mock *DataStoreQueriesStub) DeleteCodebase(ctx context.Context, id int64) error {
	if mock.DeleteCodebaseFunc == nil {
		panic("DataStoreQueriesStub.DeleteCodebaseFunc: method is nil but DataStoreQueries.DeleteCodebase was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteCodebase.Lock()
	mock.calls.DeleteCodebase = append(mock.calls.DeleteCodebase, callInfo)
	mock.lockDeleteCodebase.Unlock()
	return mock.DeleteCodebaseFunc(ctx, id)
}

// DeleteCodebaseCalls gets all the calls that were made to DeleteCodebase.
// Check the length with:
//
//	len(mockedDataStoreQueries.DeleteCodebaseCalls())
func (mock *DataStoreQueriesStub) DeleteCodebaseCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockDeleteCodebase.RLock()
	calls = mock.calls.DeleteCodebase
	mock.lockDeleteCodebase.RUnlock()
	return calls
}

// ResetDeleteCodebaseCalls reset all the calls that were made to DeleteCodebase.
func (mock *DataStoreQueriesStub) ResetDeleteCodebaseCalls() {
	mock.lockDeleteCodebase.Lock()
	mock.calls.DeleteCodebase = nil
	mock.lockDeleteCodebase.Unlock()
}

// DeleteCodebaseByProjectIdAndVersionTag calls DeleteCodebaseByProjectIdAndVersionTagFunc.
func (mock *DataStoreQueriesStub) DeleteCodebaseByProjectIdAndVersionTag(ctx context.Context, arg persister.DeleteCodebaseByProjectIdAndVersionTagParams) error {
	if mock.DeleteCodebaseByProjectIdAndVersionTagFunc == nil {
		panic("DataStoreQueriesStub.DeleteCodebaseByProjectIdAndVersionTagFunc: method is nil but DataStoreQueries.DeleteCodebaseByProjectIdAndVersionTag was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.DeleteCodebaseByProjectIdAndVersionTagParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockDeleteCodebaseByProjectIdAndVersionTag.Lock()
	mock.calls.DeleteCodebaseByProjectIdAndVersionTag = append(mock.calls.DeleteCodebaseByProjectIdAndVersionTag, callInfo)
	mock.lockDeleteCodebaseByProjectIdAndVersionTag.Unlock()
	return mock.DeleteCodebaseByProjectIdAndVersionTagFunc(ctx, arg)
}

// DeleteCodebaseByProjectIdAndVersionTagCalls gets all the calls that were made to DeleteCodebaseByProjectIdAndVersionTag.
// Check the length with:
//
//	len(mockedDataStoreQueries.DeleteCodebaseByProjectIdAndVersionTagCalls())
func (mock *DataStoreQueriesStub) DeleteCodebaseByProjectIdAndVersionTagCalls() []struct {
	Ctx context.Context
	Arg persister.DeleteCodebaseByProjectIdAndVersionTagParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.DeleteCodebaseByProjectIdAndVersionTagParams
	}
	mock.lockDeleteCodebaseByProjectIdAndVersionTag.RLock()
	calls = mock.calls.DeleteCodebaseByProjectIdAndVersionTag
	mock.lockDeleteCodebaseByProjectIdAndVersionTag.RUnlock()
	return calls
}

// ResetDeleteCodebaseByProjectIdAndVersionTagCalls reset all the calls that were made to DeleteCodebaseByProjectIdAndVersionTag.
func (mock *DataStoreQueriesStub) ResetDeleteCodebaseByProjectIdAndVersionTagCalls() {
	mock.lockDeleteCodebaseByProjectIdAndVersionTag.Lock()
	mock.calls.DeleteCodebaseByProjectIdAndVersionTag = nil
	mock.lockDeleteCodebaseByProjectIdAndVersionTag.Unlock()
}

// DeleteCodebaseSurveys calls DeleteCodebaseSurveysFunc.
func (mock *DataStoreQueriesStub) DeleteCodebaseSurveys(ctx context.Context, codebaseID int64) error {
	if mock.DeleteCodebaseSurveysFunc == nil {
		panic("DataStoreQueriesStub.DeleteCodebaseSurveysFunc: method is nil but DataStoreQueries.DeleteCodebaseSurveys was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		CodebaseID int64
	}{
		Ctx:        ctx,
		CodebaseID: codebaseID,
	}
	mock.lockDeleteCodebaseSurveys.Lock()
	mock.calls.DeleteCodebaseSurveys = append(mock.calls.DeleteCodebaseSurveys, callInfo)
	mock.lockDeleteCodebaseSurveys.Unlock()
	return mock.DeleteCodebaseSurveysFunc(ctx, codebaseID)
}

// DeleteCodebaseSurveysCalls gets all the calls that were made to DeleteCodebaseSurveys.
// Check the length with:
//
//	len(mockedDataStoreQueries.DeleteCodebaseSurveysCalls())
func (mock *DataStoreQueriesStub) DeleteCodebaseSurveysCalls() []struct {
	Ctx        context.Context
	CodebaseID int64
} {
	var calls []struct {
		Ctx        context.Context
		CodebaseID int64
	}
	mock.lockDeleteCodebaseSurveys.RLock()
	calls = mock.calls.DeleteCodebaseSurveys
	mock.lockDeleteCodebaseSurveys.RUnlock()
	return calls
}

// ResetDeleteCodebaseSurveysCalls reset all the calls that were made to DeleteCodebaseSurveys.
func (mock *DataStoreQueriesStub) ResetDeleteCodebaseSurveysCalls() {
	mock.lockDeleteCodebaseSurveys.Lock()
	mock.calls.DeleteCodebaseSurveys = nil
	mock.lockDeleteCodebaseSurveys.Unlock()
}

// DeleteFile calls DeleteFileFunc.
func (mock *DataStoreQueriesStub) DeleteFile(ctx context.Context, id int64) error {
	if mock.DeleteFileFunc == nil {
		panic("DataStoreQueriesStub.DeleteFileFunc: method is nil but DataStoreQueries.DeleteFile was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteFile.Lock()
	mock.calls.DeleteFile = append(mock.calls.DeleteFile, callInfo)
	mock.lockDeleteFile.Unlock()
	return mock.DeleteFileFunc(ctx, id)
}

// DeleteFileCalls gets all the calls that were made to DeleteFile.
// Check the length with:
//
//	len(mockedDataStoreQueries.DeleteFileCalls())
func (mock *DataStoreQueriesStub) DeleteFileCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockDeleteFile.RLock()
	calls = mock.calls.DeleteFile
	mock.lockDeleteFile.RUnlock()
	return calls
}

// ResetDeleteFileCalls reset all the calls that were made to DeleteFile.
func (mock *DataStoreQueriesStub) ResetDeleteFileCalls() {
	mock.lockDeleteFile.Lock()
	mock.calls.DeleteFile = nil
	mock.lockDeleteFile.Unlock()
}

// DeleteImport calls DeleteImportFunc.
func (mock *DataStoreQueriesStub) DeleteImport(ctx context.Context, id int64) error {
	if mock.DeleteImportFunc == nil {
		panic("DataStoreQueriesStub.DeleteImportFunc: method is nil but DataStoreQueries.DeleteImport was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteImport.Lock()
	mock.calls.DeleteImport = append(mock.calls.DeleteImport, callInfo)
	mock.lockDeleteImport.Unlock()
	return mock.DeleteImportFunc(ctx, id)
}

// DeleteImportCalls gets all the calls that were made to DeleteImport.
// Check the length with:
//
//	len(mockedDataStoreQueries.DeleteImportCalls())
func (mock *DataStoreQueriesStub) DeleteImportCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockDeleteImport.RLock()
	calls = mock.calls.DeleteImport
	mock.lockDeleteImport.RUnlock()
	return calls
}

// ResetDeleteImportCalls reset all the calls that were made to DeleteImport.
func (mock *DataStoreQueriesStub) ResetDeleteImportCalls() {
	mock.lockDeleteImport.Lock()
	mock.calls.DeleteImport = nil
	mock.lockDeleteImport.Unlock()
}

// DeleteMethod calls DeleteMethodFunc.
func (mock *DataStoreQueriesStub) DeleteMethod(ctx context.Context, id int64) error {
	if mock.DeleteMethodFunc == nil {
		panic("DataStoreQueriesStub.DeleteMethodFunc: method is nil but DataStoreQueries.DeleteMethod was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteMethod.Lock()
	mock.calls.DeleteMethod = append(mock.calls.DeleteMethod, callInfo)
	mock.lockDeleteMethod.Unlock()
	return mock.DeleteMethodFunc(ctx, id)
}

// DeleteMethodCalls gets all the calls that were made to DeleteMethod.
// Check the length with:
//
//	len(mockedDataStoreQueries.DeleteMethodCalls())
func (mock *DataStoreQueriesStub) DeleteMethodCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockDeleteMethod.RLock()
	calls = mock.calls.DeleteMethod
	mock.lockDeleteMethod.RUnlock()
	return calls
}

// ResetDeleteMethodCalls reset all the calls that were made to DeleteMethod.
func (mock *DataStoreQueriesStub) ResetDeleteMethodCalls() {
	mock.lockDeleteMethod.Lock()
	mock.calls.DeleteMethod = nil
	mock.lockDeleteMethod.Unlock()
}

// DeleteModule calls DeleteModuleFunc.
func (mock *DataStoreQueriesStub) DeleteModule(ctx context.Context, id int64) error {
	if mock.DeleteModuleFunc == nil {
		panic("DataStoreQueriesStub.DeleteModuleFunc: method is nil but DataStoreQueries.DeleteModule was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteModule.Lock()
	mock.calls.DeleteModule = append(mock.calls.DeleteModule, callInfo)
	mock.lockDeleteModule.Unlock()
	return mock.DeleteModuleFunc(ctx, id)
}

// DeleteModuleCalls gets all the calls that were made to DeleteModule.
// Check the length with:
//
//	len(mockedDataStoreQueries.DeleteModuleCalls())
func (mock *DataStoreQueriesStub) DeleteModuleCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockDeleteModule.RLock()
	calls = mock.calls.DeleteModule
	mock.lockDeleteModule.RUnlock()
	return calls
}

// ResetDeleteModuleCalls reset all the calls that were made to DeleteModule.
func (mock *DataStoreQueriesStub) ResetDeleteModuleCalls() {
	mock.lockDeleteModule.Lock()
	mock.calls.DeleteModule = nil
	mock.lockDeleteModule.Unlock()
}

// DeleteModuleVersion calls DeleteModuleVersionFunc.
func (mock *DataStoreQueriesStub) DeleteModuleVersion(ctx context.Context, id int64) error {
	if mock.DeleteModuleVersionFunc == nil {
		panic("DataStoreQueriesStub.DeleteModuleVersionFunc: method is nil but DataStoreQueries.DeleteModuleVersion was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteModuleVersion.Lock()
	mock.calls.DeleteModuleVersion = append(mock.calls.DeleteModuleVersion, callInfo)
	mock.lockDeleteModuleVersion.Unlock()
	return mock.DeleteModuleVersionFunc(ctx, id)
}

// DeleteModuleVersionCalls gets all the calls that were made to DeleteModuleVersion.
// Check the length with:
//
//	len(mockedDataStoreQueries.DeleteModuleVersionCalls())
func (mock *DataStoreQueriesStub) DeleteModuleVersionCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockDeleteModuleVersion.RLock()
	calls = mock.calls.DeleteModuleVersion
	mock.lockDeleteModuleVersion.RUnlock()
	return calls
}

// ResetDeleteModuleVersionCalls reset all the calls that were made to DeleteModuleVersion.
func (mock *DataStoreQueriesStub) ResetDeleteModuleVersionCalls() {
	mock.lockDeleteModuleVersion.Lock()
	mock.calls.DeleteModuleVersion = nil
	mock.lockDeleteModuleVersion.Unlock()
}

// DeletePackage calls DeletePackageFunc.
func (mock *DataStoreQueriesStub) DeletePackage(ctx context.Context, id int64) error {
	if mock.DeletePackageFunc == nil {
		panic("DataStoreQueriesStub.DeletePackageFunc: method is nil but DataStoreQueries.DeletePackage was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeletePackage.Lock()
	mock.calls.DeletePackage = append(mock.calls.DeletePackage, callInfo)
	mock.lockDeletePackage.Unlock()
	return mock.DeletePackageFunc(ctx, id)
}

// DeletePackageCalls gets all the calls that were made to DeletePackage.
// Check the length with:
//
//	len(mockedDataStoreQueries.DeletePackageCalls())
func (mock *DataStoreQueriesStub) DeletePackageCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockDeletePackage.RLock()
	calls = mock.calls.DeletePackage
	mock.lockDeletePackage.RUnlock()
	return calls
}

// ResetDeletePackageCalls reset all the calls that were made to DeletePackage.
func (mock *DataStoreQueriesStub) ResetDeletePackageCalls() {
	mock.lockDeletePackage.Lock()
	mock.calls.DeletePackage = nil
	mock.lockDeletePackage.Unlock()
}

// DeletePackageType calls DeletePackageTypeFunc.
func (mock *DataStoreQueriesStub) DeletePackageType(ctx context.Context, id int64) error {
	if mock.DeletePackageTypeFunc == nil {
		panic("DataStoreQueriesStub.DeletePackageTypeFunc: method is nil but DataStoreQueries.DeletePackageType was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeletePackageType.Lock()
	mock.calls.DeletePackageType = append(mock.calls.DeletePackageType, callInfo)
	mock.lockDeletePackageType.Unlock()
	return mock.DeletePackageTypeFunc(ctx, id)
}

// DeletePackageTypeCalls gets all the calls that were made to DeletePackageType.
// Check the length with:
//
//	len(mockedDataStoreQueries.DeletePackageTypeCalls())
func (mock *DataStoreQueriesStub) DeletePackageTypeCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockDeletePackageType.RLock()
	calls = mock.calls.DeletePackageType
	mock.lockDeletePackageType.RUnlock()
	return calls
}

// ResetDeletePackageTypeCalls reset all the calls that were made to DeletePackageType.
func (mock *DataStoreQueriesStub) ResetDeletePackageTypeCalls() {
	mock.lockDeletePackageType.Lock()
	mock.calls.DeletePackageType = nil
	mock.lockDeletePackageType.Unlock()
}

// DeletePackageVersion calls DeletePackageVersionFunc.
func (mock *DataStoreQueriesStub) DeletePackageVersion(ctx context.Context, id int64) error {
	if mock.DeletePackageVersionFunc == nil {
		panic("DataStoreQueriesStub.DeletePackageVersionFunc: method is nil but DataStoreQueries.DeletePackageVersion was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeletePackageVersion.Lock()
	mock.calls.DeletePackageVersion = append(mock.calls.DeletePackageVersion, callInfo)
	mock.lockDeletePackageVersion.Unlock()
	return mock.DeletePackageVersionFunc(ctx, id)
}

// DeletePackageVersionCalls gets all the calls that were made to DeletePackageVersion.
// Check the length with:
//
//	len(mockedDataStoreQueries.DeletePackageVersionCalls())
func (mock *DataStoreQueriesStub) DeletePackageVersionCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockDeletePackageVersion.RLock()
	calls = mock.calls.DeletePackageVersion
	mock.lockDeletePackageVersion.RUnlock()
	return calls
}

// ResetDeletePackageVersionCalls reset all the calls that were made to DeletePackageVersion.
func (mock *DataStoreQueriesStub) ResetDeletePackageVersionCalls() {
	mock.lockDeletePackageVersion.Lock()
	mock.calls.DeletePackageVersion = nil
	mock.lockDeletePackageVersion.Unlock()
}

// DeleteProject calls DeleteProjectFunc.
func (mock *DataStoreQueriesStub) DeleteProject(ctx context.Context, id int64) error {
	if mock.DeleteProjectFunc == nil {
		panic("DataStoreQueriesStub.DeleteProjectFunc: method is nil but DataStoreQueries.DeleteProject was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteProject.Lock()
	mock.calls.DeleteProject = append(mock.calls.DeleteProject, callInfo)
	mock.lockDeleteProject.Unlock()
	return mock.DeleteProjectFunc(ctx, id)
}

// DeleteProjectCalls gets all the calls that were made to DeleteProject.
// Check the length with:
//
//	len(mockedDataStoreQueries.DeleteProjectCalls())
func (mock *DataStoreQueriesStub) DeleteProjectCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockDeleteProject.RLock()
	calls = mock.calls.DeleteProject
	mock.lockDeleteProject.RUnlock()
	return calls
}

// ResetDeleteProjectCalls reset all the calls that were made to DeleteProject.
func (mock *DataStoreQueriesStub) ResetDeleteProjectCalls() {
	mock.lockDeleteProject.Lock()
	mock.calls.DeleteProject = nil
	mock.lockDeleteProject.Unlock()
}

// DeleteProjectByName calls DeleteProjectByNameFunc.
func (mock *DataStoreQueriesStub) DeleteProjectByName(ctx context.Context, name string) error {
	if mock.DeleteProjectByNameFunc == nil {
		panic("DataStoreQueriesStub.DeleteProjectByNameFunc: method is nil but DataStoreQueries.DeleteProjectByName was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockDeleteProjectByName.Lock()
	mock.calls.DeleteProjectByName = append(mock.calls.DeleteProjectByName, callInfo)
	mock.lockDeleteProjectByName.Unlock()
	return mock.DeleteProjectByNameFunc(ctx, name)
}

// DeleteProjectByNameCalls gets all the calls that were made to DeleteProjectByName.
// Check the length with:
//
//	len(mockedDataStoreQueries.DeleteProjectByNameCalls())
func (mock *DataStoreQueriesStub) DeleteProjectByNameCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockDeleteProjectByName.RLock()
	calls = mock.calls.DeleteProjectByName
	mock.lockDeleteProjectByName.RUnlock()
	return calls
}

// ResetDeleteProjectByNameCalls reset all the calls that were made to DeleteProjectByName.
func (mock *DataStoreQueriesStub) ResetDeleteProjectByNameCalls() {
	mock.lockDeleteProjectByName.Lock()
	mock.calls.DeleteProjectByName = nil
	mock.lockDeleteProjectByName.Unlock()
}

// DeleteSurvey calls DeleteSurveyFunc.
func (mock *DataStoreQueriesStub) DeleteSurvey(ctx context.Context, id int64) error {
	if mock.DeleteSurveyFunc == nil {
		panic("DataStoreQueriesStub.DeleteSurveyFunc: method is nil but DataStoreQueries.DeleteSurvey was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteSurvey.Lock()
	mock.calls.DeleteSurvey = append(mock.calls.DeleteSurvey, callInfo)
	mock.lockDeleteSurvey.Unlock()
	return mock.DeleteSurveyFunc(ctx, id)
}

// DeleteSurveyCalls gets all the calls that were made to DeleteSurvey.
// Check the length with:
//
//	len(mockedDataStoreQueries.DeleteSurveyCalls())
func (mock *DataStoreQueriesStub) DeleteSurveyCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockDeleteSurvey.RLock()
	calls = mock.calls.DeleteSurvey
	mock.lockDeleteSurvey.RUnlock()
	return calls
}

// ResetDeleteSurveyCalls reset all the calls that were made to DeleteSurvey.
func (mock *DataStoreQueriesStub) ResetDeleteSurveyCalls() {
	mock.lockDeleteSurvey.Lock()
	mock.calls.DeleteSurvey = nil
	mock.lockDeleteSurvey.Unlock()
}

// DeleteSurveyModule calls DeleteSurveyModuleFunc.
func (mock *DataStoreQueriesStub) DeleteSurveyModule(ctx context.Context, id int64) error {
	if mock.DeleteSurveyModuleFunc == nil {
		panic("DataStoreQueriesStub.DeleteSurveyModuleFunc: method is nil but DataStoreQueries.DeleteSurveyModule was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteSurveyModule.Lock()
	mock.calls.DeleteSurveyModule = append(mock.calls.DeleteSurveyModule, callInfo)
	mock.lockDeleteSurveyModule.Unlock()
	return mock.DeleteSurveyModuleFunc(ctx, id)
}

// DeleteSurveyModuleCalls gets all the calls that were made to DeleteSurveyModule.
// Check the length with:
//
//	len(mockedDataStoreQueries.DeleteSurveyModuleCalls())
func (mock *DataStoreQueriesStub) DeleteSurveyModuleCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockDeleteSurveyModule.RLock()
	calls = mock.calls.DeleteSurveyModule
	mock.lockDeleteSurveyModule.RUnlock()
	return calls
}

// ResetDeleteSurveyModuleCalls reset all the calls that were made to DeleteSurveyModule.
func (mock *DataStoreQueriesStub) ResetDeleteSurveyModuleCalls() {
	mock.lockDeleteSurveyModule.Lock()
	mock.calls.DeleteSurveyModule = nil
	mock.lockDeleteSurveyModule.Unlock()
}

// DeleteSymbolType calls DeleteSymbolTypeFunc.
func (mock *DataStoreQueriesStub) DeleteSymbolType(ctx context.Context, id int64) error {
	if mock.DeleteSymbolTypeFunc == nil {
		panic("DataStoreQueriesStub.DeleteSymbolTypeFunc: method is nil but DataStoreQueries.DeleteSymbolType was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteSymbolType.Lock()
	mock.calls.DeleteSymbolType = append(mock.calls.DeleteSymbolType, callInfo)
	mock.lockDeleteSymbolType.Unlock()
	return mock.DeleteSymbolTypeFunc(ctx, id)
}

// DeleteSymbolTypeCalls gets all the calls that were made to DeleteSymbolType.
// Check the length with:
//
//	len(mockedDataStoreQueries.DeleteSymbolTypeCalls())
func (mock *DataStoreQueriesStub) DeleteSymbolTypeCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockDeleteSymbolType.RLock()
	calls = mock.calls.DeleteSymbolType
	mock.lockDeleteSymbolType.RUnlock()
	return calls
}

// ResetDeleteSymbolTypeCalls reset all the calls that were made to DeleteSymbolType.
func (mock *DataStoreQueriesStub) ResetDeleteSymbolTypeCalls() {
	mock.lockDeleteSymbolType.Lock()
	mock.calls.DeleteSymbolType = nil
	mock.lockDeleteSymbolType.Unlock()
}

// DeleteType calls DeleteTypeFunc.
func (mock *DataStoreQueriesStub) DeleteType(ctx context.Context, id int64) error {
	if mock.DeleteTypeFunc == nil {
		panic("DataStoreQueriesStub.DeleteTypeFunc: method is nil but DataStoreQueries.DeleteType was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteType.Lock()
	mock.calls.DeleteType = append(mock.calls.DeleteType, callInfo)
	mock.lockDeleteType.Unlock()
	return mock.DeleteTypeFunc(ctx, id)
}

// DeleteTypeCalls gets all the calls that were made to DeleteType.
// Check the length with:
//
//	len(mockedDataStoreQueries.DeleteTypeCalls())
func (mock *DataStoreQueriesStub) DeleteTypeCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockDeleteType.RLock()
	calls = mock.calls.DeleteType
	mock.lockDeleteType.RUnlock()
	return calls
}

// ResetDeleteTypeCalls reset all the calls that were made to DeleteType.
func (mock *DataStoreQueriesStub) ResetDeleteTypeCalls() {
	mock.lockDeleteType.Lock()
	mock.calls.DeleteType = nil
	mock.lockDeleteType.Unlock()
}

// DeleteVariable calls DeleteVariableFunc.
func (mock *DataStoreQueriesStub) DeleteVariable(ctx context.Context, id int64) error {
	if mock.DeleteVariableFunc == nil {
		panic("DataStoreQueriesStub.DeleteVariableFunc: method is nil but DataStoreQueries.DeleteVariable was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteVariable.Lock()
	mock.calls.DeleteVariable = append(mock.calls.DeleteVariable, callInfo)
	mock.lockDeleteVariable.Unlock()
	return mock.DeleteVariableFunc(ctx, id)
}

// DeleteVariableCalls gets all the calls that were made to DeleteVariable.
// Check the length with:
//
//	len(mockedDataStoreQueries.DeleteVariableCalls())
func (mock *DataStoreQueriesStub) DeleteVariableCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockDeleteVariable.RLock()
	calls = mock.calls.DeleteVariable
	mock.lockDeleteVariable.RUnlock()
	return calls
}

// ResetDeleteVariableCalls reset all the calls that were made to DeleteVariable.
func (mock *DataStoreQueriesStub) ResetDeleteVariableCalls() {
	mock.lockDeleteVariable.Lock()
	mock.calls.DeleteVariable = nil
	mock.lockDeleteVariable.Unlock()
}

// InsertCategory calls InsertCategoryFunc.
func (mock *DataStoreQueriesStub) InsertCategory(ctx context.Context, arg persister.InsertCategoryParams) (persister.Category, error) {
	if mock.InsertCategoryFunc == nil {
		panic("DataStoreQueriesStub.InsertCategoryFunc: method is nil but DataStoreQueries.InsertCategory was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.InsertCategoryParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertCategory.Lock()
	mock.calls.InsertCategory = append(mock.calls.InsertCategory, callInfo)
	mock.lockInsertCategory.Unlock()
	return mock.InsertCategoryFunc(ctx, arg)
}

// InsertCategoryCalls gets all the calls that were made to InsertCategory.
// Check the length with:
//
//	len(mockedDataStoreQueries.InsertCategoryCalls())
func (mock *DataStoreQueriesStub) InsertCategoryCalls() []struct {
	Ctx context.Context
	Arg persister.InsertCategoryParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.InsertCategoryParams
	}
	mock.lockInsertCategory.RLock()
	calls = mock.calls.InsertCategory
	mock.lockInsertCategory.RUnlock()
	return calls
}

// ResetInsertCategoryCalls reset all the calls that were made to InsertCategory.
func (mock *DataStoreQueriesStub) ResetInsertCategoryCalls() {
	mock.lockInsertCategory.Lock()
	mock.calls.InsertCategory = nil
	mock.lockInsertCategory.Unlock()
}

// InsertCodebase calls InsertCodebaseFunc.
func (mock *DataStoreQueriesStub) InsertCodebase(ctx context.Context, arg persister.InsertCodebaseParams) (persister.Codebase, error) {
	if mock.InsertCodebaseFunc == nil {
		panic("DataStoreQueriesStub.InsertCodebaseFunc: method is nil but DataStoreQueries.InsertCodebase was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.InsertCodebaseParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertCodebase.Lock()
	mock.calls.InsertCodebase = append(mock.calls.InsertCodebase, callInfo)
	mock.lockInsertCodebase.Unlock()
	return mock.InsertCodebaseFunc(ctx, arg)
}

// InsertCodebaseCalls gets all the calls that were made to InsertCodebase.
// Check the length with:
//
//	len(mockedDataStoreQueries.InsertCodebaseCalls())
func (mock *DataStoreQueriesStub) InsertCodebaseCalls() []struct {
	Ctx context.Context
	Arg persister.InsertCodebaseParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.InsertCodebaseParams
	}
	mock.lockInsertCodebase.RLock()
	calls = mock.calls.InsertCodebase
	mock.lockInsertCodebase.RUnlock()
	return calls
}

// ResetInsertCodebaseCalls reset all the calls that were made to InsertCodebase.
func (mock *DataStoreQueriesStub) ResetInsertCodebaseCalls() {
	mock.lockInsertCodebase.Lock()
	mock.calls.InsertCodebase = nil
	mock.lockInsertCodebase.Unlock()
}

// InsertFile calls InsertFileFunc.
func (mock *DataStoreQueriesStub) InsertFile(ctx context.Context, arg persister.InsertFileParams) (persister.File, error) {
	if mock.InsertFileFunc == nil {
		panic("DataStoreQueriesStub.InsertFileFunc: method is nil but DataStoreQueries.InsertFile was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.InsertFileParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertFile.Lock()
	mock.calls.InsertFile = append(mock.calls.InsertFile, callInfo)
	mock.lockInsertFile.Unlock()
	return mock.InsertFileFunc(ctx, arg)
}

// InsertFileCalls gets all the calls that were made to InsertFile.
// Check the length with:
//
//	len(mockedDataStoreQueries.InsertFileCalls())
func (mock *DataStoreQueriesStub) InsertFileCalls() []struct {
	Ctx context.Context
	Arg persister.InsertFileParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.InsertFileParams
	}
	mock.lockInsertFile.RLock()
	calls = mock.calls.InsertFile
	mock.lockInsertFile.RUnlock()
	return calls
}

// ResetInsertFileCalls reset all the calls that were made to InsertFile.
func (mock *DataStoreQueriesStub) ResetInsertFileCalls() {
	mock.lockInsertFile.Lock()
	mock.calls.InsertFile = nil
	mock.lockInsertFile.Unlock()
}

// InsertImport calls InsertImportFunc.
func (mock *DataStoreQueriesStub) InsertImport(ctx context.Context, arg persister.InsertImportParams) (persister.Import, error) {
	if mock.InsertImportFunc == nil {
		panic("DataStoreQueriesStub.InsertImportFunc: method is nil but DataStoreQueries.InsertImport was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.InsertImportParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertImport.Lock()
	mock.calls.InsertImport = append(mock.calls.InsertImport, callInfo)
	mock.lockInsertImport.Unlock()
	return mock.InsertImportFunc(ctx, arg)
}

// InsertImportCalls gets all the calls that were made to InsertImport.
// Check the length with:
//
//	len(mockedDataStoreQueries.InsertImportCalls())
func (mock *DataStoreQueriesStub) InsertImportCalls() []struct {
	Ctx context.Context
	Arg persister.InsertImportParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.InsertImportParams
	}
	mock.lockInsertImport.RLock()
	calls = mock.calls.InsertImport
	mock.lockInsertImport.RUnlock()
	return calls
}

// ResetInsertImportCalls reset all the calls that were made to InsertImport.
func (mock *DataStoreQueriesStub) ResetInsertImportCalls() {
	mock.lockInsertImport.Lock()
	mock.calls.InsertImport = nil
	mock.lockInsertImport.Unlock()
}

// InsertMethod calls InsertMethodFunc.
func (mock *DataStoreQueriesStub) InsertMethod(ctx context.Context, arg persister.InsertMethodParams) (persister.Method, error) {
	if mock.InsertMethodFunc == nil {
		panic("DataStoreQueriesStub.InsertMethodFunc: method is nil but DataStoreQueries.InsertMethod was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.InsertMethodParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertMethod.Lock()
	mock.calls.InsertMethod = append(mock.calls.InsertMethod, callInfo)
	mock.lockInsertMethod.Unlock()
	return mock.InsertMethodFunc(ctx, arg)
}

// InsertMethodCalls gets all the calls that were made to InsertMethod.
// Check the length with:
//
//	len(mockedDataStoreQueries.InsertMethodCalls())
func (mock *DataStoreQueriesStub) InsertMethodCalls() []struct {
	Ctx context.Context
	Arg persister.InsertMethodParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.InsertMethodParams
	}
	mock.lockInsertMethod.RLock()
	calls = mock.calls.InsertMethod
	mock.lockInsertMethod.RUnlock()
	return calls
}

// ResetInsertMethodCalls reset all the calls that were made to InsertMethod.
func (mock *DataStoreQueriesStub) ResetInsertMethodCalls() {
	mock.lockInsertMethod.Lock()
	mock.calls.InsertMethod = nil
	mock.lockInsertMethod.Unlock()
}

// InsertModule calls InsertModuleFunc.
func (mock *DataStoreQueriesStub) InsertModule(ctx context.Context, name string) (persister.Module, error) {
	if mock.InsertModuleFunc == nil {
		panic("DataStoreQueriesStub.InsertModuleFunc: method is nil but DataStoreQueries.InsertModule was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockInsertModule.Lock()
	mock.calls.InsertModule = append(mock.calls.InsertModule, callInfo)
	mock.lockInsertModule.Unlock()
	return mock.InsertModuleFunc(ctx, name)
}

// InsertModuleCalls gets all the calls that were made to InsertModule.
// Check the length with:
//
//	len(mockedDataStoreQueries.InsertModuleCalls())
func (mock *DataStoreQueriesStub) InsertModuleCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockInsertModule.RLock()
	calls = mock.calls.InsertModule
	mock.lockInsertModule.RUnlock()
	return calls
}

// ResetInsertModuleCalls reset all the calls that were made to InsertModule.
func (mock *DataStoreQueriesStub) ResetInsertModuleCalls() {
	mock.lockInsertModule.Lock()
	mock.calls.InsertModule = nil
	mock.lockInsertModule.Unlock()
}

// InsertModuleVersion calls InsertModuleVersionFunc.
func (mock *DataStoreQueriesStub) InsertModuleVersion(ctx context.Context, arg persister.InsertModuleVersionParams) (persister.ModuleVersion, error) {
	if mock.InsertModuleVersionFunc == nil {
		panic("DataStoreQueriesStub.InsertModuleVersionFunc: method is nil but DataStoreQueries.InsertModuleVersion was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.InsertModuleVersionParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertModuleVersion.Lock()
	mock.calls.InsertModuleVersion = append(mock.calls.InsertModuleVersion, callInfo)
	mock.lockInsertModuleVersion.Unlock()
	return mock.InsertModuleVersionFunc(ctx, arg)
}

// InsertModuleVersionCalls gets all the calls that were made to InsertModuleVersion.
// Check the length with:
//
//	len(mockedDataStoreQueries.InsertModuleVersionCalls())
func (mock *DataStoreQueriesStub) InsertModuleVersionCalls() []struct {
	Ctx context.Context
	Arg persister.InsertModuleVersionParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.InsertModuleVersionParams
	}
	mock.lockInsertModuleVersion.RLock()
	calls = mock.calls.InsertModuleVersion
	mock.lockInsertModuleVersion.RUnlock()
	return calls
}

// ResetInsertModuleVersionCalls reset all the calls that were made to InsertModuleVersion.
func (mock *DataStoreQueriesStub) ResetInsertModuleVersionCalls() {
	mock.lockInsertModuleVersion.Lock()
	mock.calls.InsertModuleVersion = nil
	mock.lockInsertModuleVersion.Unlock()
}

// InsertPackage calls InsertPackageFunc.
func (mock *DataStoreQueriesStub) InsertPackage(ctx context.Context, arg persister.InsertPackageParams) (persister.Package, error) {
	if mock.InsertPackageFunc == nil {
		panic("DataStoreQueriesStub.InsertPackageFunc: method is nil but DataStoreQueries.InsertPackage was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.InsertPackageParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertPackage.Lock()
	mock.calls.InsertPackage = append(mock.calls.InsertPackage, callInfo)
	mock.lockInsertPackage.Unlock()
	return mock.InsertPackageFunc(ctx, arg)
}

// InsertPackageCalls gets all the calls that were made to InsertPackage.
// Check the length with:
//
//	len(mockedDataStoreQueries.InsertPackageCalls())
func (mock *DataStoreQueriesStub) InsertPackageCalls() []struct {
	Ctx context.Context
	Arg persister.InsertPackageParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.InsertPackageParams
	}
	mock.lockInsertPackage.RLock()
	calls = mock.calls.InsertPackage
	mock.lockInsertPackage.RUnlock()
	return calls
}

// ResetInsertPackageCalls reset all the calls that were made to InsertPackage.
func (mock *DataStoreQueriesStub) ResetInsertPackageCalls() {
	mock.lockInsertPackage.Lock()
	mock.calls.InsertPackage = nil
	mock.lockInsertPackage.Unlock()
}

// InsertPackageType calls InsertPackageTypeFunc.
func (mock *DataStoreQueriesStub) InsertPackageType(ctx context.Context, arg persister.InsertPackageTypeParams) (persister.PackageType, error) {
	if mock.InsertPackageTypeFunc == nil {
		panic("DataStoreQueriesStub.InsertPackageTypeFunc: method is nil but DataStoreQueries.InsertPackageType was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.InsertPackageTypeParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertPackageType.Lock()
	mock.calls.InsertPackageType = append(mock.calls.InsertPackageType, callInfo)
	mock.lockInsertPackageType.Unlock()
	return mock.InsertPackageTypeFunc(ctx, arg)
}

// InsertPackageTypeCalls gets all the calls that were made to InsertPackageType.
// Check the length with:
//
//	len(mockedDataStoreQueries.InsertPackageTypeCalls())
func (mock *DataStoreQueriesStub) InsertPackageTypeCalls() []struct {
	Ctx context.Context
	Arg persister.InsertPackageTypeParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.InsertPackageTypeParams
	}
	mock.lockInsertPackageType.RLock()
	calls = mock.calls.InsertPackageType
	mock.lockInsertPackageType.RUnlock()
	return calls
}

// ResetInsertPackageTypeCalls reset all the calls that were made to InsertPackageType.
func (mock *DataStoreQueriesStub) ResetInsertPackageTypeCalls() {
	mock.lockInsertPackageType.Lock()
	mock.calls.InsertPackageType = nil
	mock.lockInsertPackageType.Unlock()
}

// InsertPackageVersion calls InsertPackageVersionFunc.
func (mock *DataStoreQueriesStub) InsertPackageVersion(ctx context.Context, arg persister.InsertPackageVersionParams) (persister.PackageVersion, error) {
	if mock.InsertPackageVersionFunc == nil {
		panic("DataStoreQueriesStub.InsertPackageVersionFunc: method is nil but DataStoreQueries.InsertPackageVersion was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.InsertPackageVersionParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertPackageVersion.Lock()
	mock.calls.InsertPackageVersion = append(mock.calls.InsertPackageVersion, callInfo)
	mock.lockInsertPackageVersion.Unlock()
	return mock.InsertPackageVersionFunc(ctx, arg)
}

// InsertPackageVersionCalls gets all the calls that were made to InsertPackageVersion.
// Check the length with:
//
//	len(mockedDataStoreQueries.InsertPackageVersionCalls())
func (mock *DataStoreQueriesStub) InsertPackageVersionCalls() []struct {
	Ctx context.Context
	Arg persister.InsertPackageVersionParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.InsertPackageVersionParams
	}
	mock.lockInsertPackageVersion.RLock()
	calls = mock.calls.InsertPackageVersion
	mock.lockInsertPackageVersion.RUnlock()
	return calls
}

// ResetInsertPackageVersionCalls reset all the calls that were made to InsertPackageVersion.
func (mock *DataStoreQueriesStub) ResetInsertPackageVersionCalls() {
	mock.lockInsertPackageVersion.Lock()
	mock.calls.InsertPackageVersion = nil
	mock.lockInsertPackageVersion.Unlock()
}

// InsertProject calls InsertProjectFunc.
func (mock *DataStoreQueriesStub) InsertProject(ctx context.Context, arg persister.InsertProjectParams) (persister.Project, error) {
	if mock.InsertProjectFunc == nil {
		panic("DataStoreQueriesStub.InsertProjectFunc: method is nil but DataStoreQueries.InsertProject was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.InsertProjectParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertProject.Lock()
	mock.calls.InsertProject = append(mock.calls.InsertProject, callInfo)
	mock.lockInsertProject.Unlock()
	return mock.InsertProjectFunc(ctx, arg)
}

// InsertProjectCalls gets all the calls that were made to InsertProject.
// Check the length with:
//
//	len(mockedDataStoreQueries.InsertProjectCalls())
func (mock *DataStoreQueriesStub) InsertProjectCalls() []struct {
	Ctx context.Context
	Arg persister.InsertProjectParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.InsertProjectParams
	}
	mock.lockInsertProject.RLock()
	calls = mock.calls.InsertProject
	mock.lockInsertProject.RUnlock()
	return calls
}

// ResetInsertProjectCalls reset all the calls that were made to InsertProject.
func (mock *DataStoreQueriesStub) ResetInsertProjectCalls() {
	mock.lockInsertProject.Lock()
	mock.calls.InsertProject = nil
	mock.lockInsertProject.Unlock()
}

// InsertSurvey calls InsertSurveyFunc.
func (mock *DataStoreQueriesStub) InsertSurvey(ctx context.Context, arg persister.InsertSurveyParams) (persister.Survey, error) {
	if mock.InsertSurveyFunc == nil {
		panic("DataStoreQueriesStub.InsertSurveyFunc: method is nil but DataStoreQueries.InsertSurvey was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.InsertSurveyParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertSurvey.Lock()
	mock.calls.InsertSurvey = append(mock.calls.InsertSurvey, callInfo)
	mock.lockInsertSurvey.Unlock()
	return mock.InsertSurveyFunc(ctx, arg)
}

// InsertSurveyCalls gets all the calls that were made to InsertSurvey.
// Check the length with:
//
//	len(mockedDataStoreQueries.InsertSurveyCalls())
func (mock *DataStoreQueriesStub) InsertSurveyCalls() []struct {
	Ctx context.Context
	Arg persister.InsertSurveyParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.InsertSurveyParams
	}
	mock.lockInsertSurvey.RLock()
	calls = mock.calls.InsertSurvey
	mock.lockInsertSurvey.RUnlock()
	return calls
}

// ResetInsertSurveyCalls reset all the calls that were made to InsertSurvey.
func (mock *DataStoreQueriesStub) ResetInsertSurveyCalls() {
	mock.lockInsertSurvey.Lock()
	mock.calls.InsertSurvey = nil
	mock.lockInsertSurvey.Unlock()
}

// InsertSurveyModule calls InsertSurveyModuleFunc.
func (mock *DataStoreQueriesStub) InsertSurveyModule(ctx context.Context, arg persister.InsertSurveyModuleParams) (persister.SurveyModule, error) {
	if mock.InsertSurveyModuleFunc == nil {
		panic("DataStoreQueriesStub.InsertSurveyModuleFunc: method is nil but DataStoreQueries.InsertSurveyModule was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.InsertSurveyModuleParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertSurveyModule.Lock()
	mock.calls.InsertSurveyModule = append(mock.calls.InsertSurveyModule, callInfo)
	mock.lockInsertSurveyModule.Unlock()
	return mock.InsertSurveyModuleFunc(ctx, arg)
}

// InsertSurveyModuleCalls gets all the calls that were made to InsertSurveyModule.
// Check the length with:
//
//	len(mockedDataStoreQueries.InsertSurveyModuleCalls())
func (mock *DataStoreQueriesStub) InsertSurveyModuleCalls() []struct {
	Ctx context.Context
	Arg persister.InsertSurveyModuleParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.InsertSurveyModuleParams
	}
	mock.lockInsertSurveyModule.RLock()
	calls = mock.calls.InsertSurveyModule
	mock.lockInsertSurveyModule.RUnlock()
	return calls
}

// ResetInsertSurveyModuleCalls reset all the calls that were made to InsertSurveyModule.
func (mock *DataStoreQueriesStub) ResetInsertSurveyModuleCalls() {
	mock.lockInsertSurveyModule.Lock()
	mock.calls.InsertSurveyModule = nil
	mock.lockInsertSurveyModule.Unlock()
}

// InsertSymbolType calls InsertSymbolTypeFunc.
func (mock *DataStoreQueriesStub) InsertSymbolType(ctx context.Context, arg persister.InsertSymbolTypeParams) (persister.SymbolType, error) {
	if mock.InsertSymbolTypeFunc == nil {
		panic("DataStoreQueriesStub.InsertSymbolTypeFunc: method is nil but DataStoreQueries.InsertSymbolType was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.InsertSymbolTypeParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertSymbolType.Lock()
	mock.calls.InsertSymbolType = append(mock.calls.InsertSymbolType, callInfo)
	mock.lockInsertSymbolType.Unlock()
	return mock.InsertSymbolTypeFunc(ctx, arg)
}

// InsertSymbolTypeCalls gets all the calls that were made to InsertSymbolType.
// Check the length with:
//
//	len(mockedDataStoreQueries.InsertSymbolTypeCalls())
func (mock *DataStoreQueriesStub) InsertSymbolTypeCalls() []struct {
	Ctx context.Context
	Arg persister.InsertSymbolTypeParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.InsertSymbolTypeParams
	}
	mock.lockInsertSymbolType.RLock()
	calls = mock.calls.InsertSymbolType
	mock.lockInsertSymbolType.RUnlock()
	return calls
}

// ResetInsertSymbolTypeCalls reset all the calls that were made to InsertSymbolType.
func (mock *DataStoreQueriesStub) ResetInsertSymbolTypeCalls() {
	mock.lockInsertSymbolType.Lock()
	mock.calls.InsertSymbolType = nil
	mock.lockInsertSymbolType.Unlock()
}

// InsertType calls InsertTypeFunc.
func (mock *DataStoreQueriesStub) InsertType(ctx context.Context, arg persister.InsertTypeParams) (persister.Type, error) {
	if mock.InsertTypeFunc == nil {
		panic("DataStoreQueriesStub.InsertTypeFunc: method is nil but DataStoreQueries.InsertType was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.InsertTypeParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertType.Lock()
	mock.calls.InsertType = append(mock.calls.InsertType, callInfo)
	mock.lockInsertType.Unlock()
	return mock.InsertTypeFunc(ctx, arg)
}

// InsertTypeCalls gets all the calls that were made to InsertType.
// Check the length with:
//
//	len(mockedDataStoreQueries.InsertTypeCalls())
func (mock *DataStoreQueriesStub) InsertTypeCalls() []struct {
	Ctx context.Context
	Arg persister.InsertTypeParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.InsertTypeParams
	}
	mock.lockInsertType.RLock()
	calls = mock.calls.InsertType
	mock.lockInsertType.RUnlock()
	return calls
}

// ResetInsertTypeCalls reset all the calls that were made to InsertType.
func (mock *DataStoreQueriesStub) ResetInsertTypeCalls() {
	mock.lockInsertType.Lock()
	mock.calls.InsertType = nil
	mock.lockInsertType.Unlock()
}

// InsertVariable calls InsertVariableFunc.
func (mock *DataStoreQueriesStub) InsertVariable(ctx context.Context, arg persister.InsertVariableParams) (persister.Variable, error) {
	if mock.InsertVariableFunc == nil {
		panic("DataStoreQueriesStub.InsertVariableFunc: method is nil but DataStoreQueries.InsertVariable was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.InsertVariableParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockInsertVariable.Lock()
	mock.calls.InsertVariable = append(mock.calls.InsertVariable, callInfo)
	mock.lockInsertVariable.Unlock()
	return mock.InsertVariableFunc(ctx, arg)
}

// InsertVariableCalls gets all the calls that were made to InsertVariable.
// Check the length with:
//
//	len(mockedDataStoreQueries.InsertVariableCalls())
func (mock *DataStoreQueriesStub) InsertVariableCalls() []struct {
	Ctx context.Context
	Arg persister.InsertVariableParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.InsertVariableParams
	}
	mock.lockInsertVariable.RLock()
	calls = mock.calls.InsertVariable
	mock.lockInsertVariable.RUnlock()
	return calls
}

// ResetInsertVariableCalls reset all the calls that were made to InsertVariable.
func (mock *DataStoreQueriesStub) ResetInsertVariableCalls() {
	mock.lockInsertVariable.Lock()
	mock.calls.InsertVariable = nil
	mock.lockInsertVariable.Unlock()
}

// ListCategories calls ListCategoriesFunc.
func (mock *DataStoreQueriesStub) ListCategories(ctx context.Context) ([]persister.Category, error) {
	if mock.ListCategoriesFunc == nil {
		panic("DataStoreQueriesStub.ListCategoriesFunc: method is nil but DataStoreQueries.ListCategories was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListCategories.Lock()
	mock.calls.ListCategories = append(mock.calls.ListCategories, callInfo)
	mock.lockListCategories.Unlock()
	return mock.ListCategoriesFunc(ctx)
}

// ListCategoriesCalls gets all the calls that were made to ListCategories.
// Check the length with:
//
//	len(mockedDataStoreQueries.ListCategoriesCalls())
func (mock *DataStoreQueriesStub) ListCategoriesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListCategories.RLock()
	calls = mock.calls.ListCategories
	mock.lockListCategories.RUnlock()
	return calls
}

// ResetListCategoriesCalls reset all the calls that were made to ListCategories.
func (mock *DataStoreQueriesStub) ResetListCategoriesCalls() {
	mock.lockListCategories.Lock()
	mock.calls.ListCategories = nil
	mock.lockListCategories.Unlock()
}

// ListCodebaseSurveys calls ListCodebaseSurveysFunc.
func (mock *DataStoreQueriesStub) ListCodebaseSurveys(ctx context.Context, codebaseID int64) ([]persister.Survey, error) {
	if mock.ListCodebaseSurveysFunc == nil {
		panic("DataStoreQueriesStub.ListCodebaseSurveysFunc: method is nil but DataStoreQueries.ListCodebaseSurveys was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		CodebaseID int64
	}{
		Ctx:        ctx,
		CodebaseID: codebaseID,
	}
	mock.lockListCodebaseSurveys.Lock()
	mock.calls.ListCodebaseSurveys = append(mock.calls.ListCodebaseSurveys, callInfo)
	mock.lockListCodebaseSurveys.Unlock()
	return mock.ListCodebaseSurveysFunc(ctx, codebaseID)
}

// ListCodebaseSurveysCalls gets all the calls that were made to ListCodebaseSurveys.
// Check the length with:
//
//	len(mockedDataStoreQueries.ListCodebaseSurveysCalls())
func (mock *DataStoreQueriesStub) ListCodebaseSurveysCalls() []struct {
	Ctx        context.Context
	CodebaseID int64
} {
	var calls []struct {
		Ctx        context.Context
		CodebaseID int64
	}
	mock.lockListCodebaseSurveys.RLock()
	calls = mock.calls.ListCodebaseSurveys
	mock.lockListCodebaseSurveys.RUnlock()
	return calls
}

// ResetListCodebaseSurveysCalls reset all the calls that were made to ListCodebaseSurveys.
func (mock *DataStoreQueriesStub) ResetListCodebaseSurveysCalls() {
	mock.lockListCodebaseSurveys.Lock()
	mock.calls.ListCodebaseSurveys = nil
	mock.lockListCodebaseSurveys.Unlock()
}

// ListCodebases calls ListCodebasesFunc.
func (mock *DataStoreQueriesStub) ListCodebases(ctx context.Context) ([]persister.Codebase, error) {
	if mock.ListCodebasesFunc == nil {
		panic("DataStoreQueriesStub.ListCodebasesFunc: method is nil but DataStoreQueries.ListCodebases was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListCodebases.Lock()
	mock.calls.ListCodebases = append(mock.calls.ListCodebases, callInfo)
	mock.lockListCodebases.Unlock()
	return mock.ListCodebasesFunc(ctx)
}

// ListCodebasesCalls gets all the calls that were made to ListCodebases.
// Check the length with:
//
//	len(mockedDataStoreQueries.ListCodebasesCalls())
func (mock *DataStoreQueriesStub) ListCodebasesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListCodebases.RLock()
	calls = mock.calls.ListCodebases
	mock.lockListCodebases.RUnlock()
	return calls
}

// ResetListCodebasesCalls reset all the calls that were made to ListCodebases.
func (mock *DataStoreQueriesStub) ResetListCodebasesCalls() {
	mock.lockListCodebases.Lock()
	mock.calls.ListCodebases = nil
	mock.lockListCodebases.Unlock()
}

// ListFiles calls ListFilesFunc.
func (mock *DataStoreQueriesStub) ListFiles(ctx context.Context) ([]persister.File, error) {
	if mock.ListFilesFunc == nil {
		panic("DataStoreQueriesStub.ListFilesFunc: method is nil but DataStoreQueries.ListFiles was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListFiles.Lock()
	mock.calls.ListFiles = append(mock.calls.ListFiles, callInfo)
	mock.lockListFiles.Unlock()
	return mock.ListFilesFunc(ctx)
}

// ListFilesCalls gets all the calls that were made to ListFiles.
// Check the length with:
//
//	len(mockedDataStoreQueries.ListFilesCalls())
func (mock *DataStoreQueriesStub) ListFilesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListFiles.RLock()
	calls = mock.calls.ListFiles
	mock.lockListFiles.RUnlock()
	return calls
}

// ResetListFilesCalls reset all the calls that were made to ListFiles.
func (mock *DataStoreQueriesStub) ResetListFilesCalls() {
	mock.lockListFiles.Lock()
	mock.calls.ListFiles = nil
	mock.lockListFiles.Unlock()
}

// ListFilesBySurvey calls ListFilesBySurveyFunc.
func (mock *DataStoreQueriesStub) ListFilesBySurvey(ctx context.Context, surveyID int64) ([]persister.File, error) {
	if mock.ListFilesBySurveyFunc == nil {
		panic("DataStoreQueriesStub.ListFilesBySurveyFunc: method is nil but DataStoreQueries.ListFilesBySurvey was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		SurveyID int64
	}{
		Ctx:      ctx,
		SurveyID: surveyID,
	}
	mock.lockListFilesBySurvey.Lock()
	mock.calls.ListFilesBySurvey = append(mock.calls.ListFilesBySurvey, callInfo)
	mock.lockListFilesBySurvey.Unlock()
	return mock.ListFilesBySurveyFunc(ctx, surveyID)
}

// ListFilesBySurveyCalls gets all the calls that were made to ListFilesBySurvey.
// Check the length with:
//
//	len(mockedDataStoreQueries.ListFilesBySurveyCalls())
func (mock *DataStoreQueriesStub) ListFilesBySurveyCalls() []struct {
	Ctx      context.Context
	SurveyID int64
} {
	var calls []struct {
		Ctx      context.Context
		SurveyID int64
	}
	mock.lockListFilesBySurvey.RLock()
	calls = mock.calls.ListFilesBySurvey
	mock.lockListFilesBySurvey.RUnlock()
	return calls
}

// ResetListFilesBySurveyCalls reset all the calls that were made to ListFilesBySurvey.
func (mock *DataStoreQueriesStub) ResetListFilesBySurveyCalls() {
	mock.lockListFilesBySurvey.Lock()
	mock.calls.ListFilesBySurvey = nil
	mock.lockListFilesBySurvey.Unlock()
}

// ListImports calls ListImportsFunc.
func (mock *DataStoreQueriesStub) ListImports(ctx context.Context) ([]persister.Import, error) {
	if mock.ListImportsFunc == nil {
		panic("DataStoreQueriesStub.ListImportsFunc: method is nil but DataStoreQueries.ListImports was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListImports.Lock()
	mock.calls.ListImports = append(mock.calls.ListImports, callInfo)
	mock.lockListImports.Unlock()
	return mock.ListImportsFunc(ctx)
}

// ListImportsCalls gets all the calls that were made to ListImports.
// Check the length with:
//
//	len(mockedDataStoreQueries.ListImportsCalls())
func (mock *DataStoreQueriesStub) ListImportsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListImports.RLock()
	calls = mock.calls.ListImports
	mock.lockListImports.RUnlock()
	return calls
}

// ResetListImportsCalls reset all the calls that were made to ListImports.
func (mock *DataStoreQueriesStub) ResetListImportsCalls() {
	mock.lockListImports.Lock()
	mock.calls.ListImports = nil
	mock.lockListImports.Unlock()
}

// ListMethods calls ListMethodsFunc.
func (mock *DataStoreQueriesStub) ListMethods(ctx context.Context) ([]persister.Method, error) {
	if mock.ListMethodsFunc == nil {
		panic("DataStoreQueriesStub.ListMethodsFunc: method is nil but DataStoreQueries.ListMethods was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListMethods.Lock()
	mock.calls.ListMethods = append(mock.calls.ListMethods, callInfo)
	mock.lockListMethods.Unlock()
	return mock.ListMethodsFunc(ctx)
}

// ListMethodsCalls gets all the calls that were made to ListMethods.
// Check the length with:
//
//	len(mockedDataStoreQueries.ListMethodsCalls())
func (mock *DataStoreQueriesStub) ListMethodsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListMethods.RLock()
	calls = mock.calls.ListMethods
	mock.lockListMethods.RUnlock()
	return calls
}

// ResetListMethodsCalls reset all the calls that were made to ListMethods.
func (mock *DataStoreQueriesStub) ResetListMethodsCalls() {
	mock.lockListMethods.Lock()
	mock.calls.ListMethods = nil
	mock.lockListMethods.Unlock()
}

// ListModuleVersions calls ListModuleVersionsFunc.
func (mock *DataStoreQueriesStub) ListModuleVersions(ctx context.Context) ([]persister.ModuleVersion, error) {
	if mock.ListModuleVersionsFunc == nil {
		panic("DataStoreQueriesStub.ListModuleVersionsFunc: method is nil but DataStoreQueries.ListModuleVersions was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListModuleVersions.Lock()
	mock.calls.ListModuleVersions = append(mock.calls.ListModuleVersions, callInfo)
	mock.lockListModuleVersions.Unlock()
	return mock.ListModuleVersionsFunc(ctx)
}

// ListModuleVersionsCalls gets all the calls that were made to ListModuleVersions.
// Check the length with:
//
//	len(mockedDataStoreQueries.ListModuleVersionsCalls())
func (mock *DataStoreQueriesStub) ListModuleVersionsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListModuleVersions.RLock()
	calls = mock.calls.ListModuleVersions
	mock.lockListModuleVersions.RUnlock()
	return calls
}

// ResetListModuleVersionsCalls reset all the calls that were made to ListModuleVersions.
func (mock *DataStoreQueriesStub) ResetListModuleVersionsCalls() {
	mock.lockListModuleVersions.Lock()
	mock.calls.ListModuleVersions = nil
	mock.lockListModuleVersions.Unlock()
}

// ListModules calls ListModulesFunc.
func (mock *DataStoreQueriesStub) ListModules(ctx context.Context) ([]persister.Module, error) {
	if mock.ListModulesFunc == nil {
		panic("DataStoreQueriesStub.ListModulesFunc: method is nil but DataStoreQueries.ListModules was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListModules.Lock()
	mock.calls.ListModules = append(mock.calls.ListModules, callInfo)
	mock.lockListModules.Unlock()
	return mock.ListModulesFunc(ctx)
}

// ListModulesCalls gets all the calls that were made to ListModules.
// Check the length with:
//
//	len(mockedDataStoreQueries.ListModulesCalls())
func (mock *DataStoreQueriesStub) ListModulesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListModules.RLock()
	calls = mock.calls.ListModules
	mock.lockListModules.RUnlock()
	return calls
}

// ResetListModulesCalls reset all the calls that were made to ListModules.
func (mock *DataStoreQueriesStub) ResetListModulesCalls() {
	mock.lockListModules.Lock()
	mock.calls.ListModules = nil
	mock.lockListModules.Unlock()
}

// ListPackageTypes calls ListPackageTypesFunc.
func (mock *DataStoreQueriesStub) ListPackageTypes(ctx context.Context) ([]persister.PackageType, error) {
	if mock.ListPackageTypesFunc == nil {
		panic("DataStoreQueriesStub.ListPackageTypesFunc: method is nil but DataStoreQueries.ListPackageTypes was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListPackageTypes.Lock()
	mock.calls.ListPackageTypes = append(mock.calls.ListPackageTypes, callInfo)
	mock.lockListPackageTypes.Unlock()
	return mock.ListPackageTypesFunc(ctx)
}

// ListPackageTypesCalls gets all the calls that were made to ListPackageTypes.
// Check the length with:
//
//	len(mockedDataStoreQueries.ListPackageTypesCalls())
func (mock *DataStoreQueriesStub) ListPackageTypesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListPackageTypes.RLock()
	calls = mock.calls.ListPackageTypes
	mock.lockListPackageTypes.RUnlock()
	return calls
}

// ResetListPackageTypesCalls reset all the calls that were made to ListPackageTypes.
func (mock *DataStoreQueriesStub) ResetListPackageTypesCalls() {
	mock.lockListPackageTypes.Lock()
	mock.calls.ListPackageTypes = nil
	mock.lockListPackageTypes.Unlock()
}

// ListPackageTypesByName calls ListPackageTypesByNameFunc.
func (mock *DataStoreQueriesStub) ListPackageTypesByName(ctx context.Context) ([]persister.PackageType, error) {
	if mock.ListPackageTypesByNameFunc == nil {
		panic("DataStoreQueriesStub.ListPackageTypesByNameFunc: method is nil but DataStoreQueries.ListPackageTypesByName was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListPackageTypesByName.Lock()
	mock.calls.ListPackageTypesByName = append(mock.calls.ListPackageTypesByName, callInfo)
	mock.lockListPackageTypesByName.Unlock()
	return mock.ListPackageTypesByNameFunc(ctx)
}

// ListPackageTypesByNameCalls gets all the calls that were made to ListPackageTypesByName.
// Check the length with:
//
//	len(mockedDataStoreQueries.ListPackageTypesByNameCalls())
func (mock *DataStoreQueriesStub) ListPackageTypesByNameCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListPackageTypesByName.RLock()
	calls = mock.calls.ListPackageTypesByName
	mock.lockListPackageTypesByName.RUnlock()
	return calls
}

// ResetListPackageTypesByNameCalls reset all the calls that were made to ListPackageTypesByName.
func (mock *DataStoreQueriesStub) ResetListPackageTypesByNameCalls() {
	mock.lockListPackageTypesByName.Lock()
	mock.calls.ListPackageTypesByName = nil
	mock.lockListPackageTypesByName.Unlock()
}

// ListPackageVersions calls ListPackageVersionsFunc.
func (mock *DataStoreQueriesStub) ListPackageVersions(ctx context.Context) ([]persister.PackageVersion, error) {
	if mock.ListPackageVersionsFunc == nil {
		panic("DataStoreQueriesStub.ListPackageVersionsFunc: method is nil but DataStoreQueries.ListPackageVersions was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListPackageVersions.Lock()
	mock.calls.ListPackageVersions = append(mock.calls.ListPackageVersions, callInfo)
	mock.lockListPackageVersions.Unlock()
	return mock.ListPackageVersionsFunc(ctx)
}

// ListPackageVersionsCalls gets all the calls that were made to ListPackageVersions.
// Check the length with:
//
//	len(mockedDataStoreQueries.ListPackageVersionsCalls())
func (mock *DataStoreQueriesStub) ListPackageVersionsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListPackageVersions.RLock()
	calls = mock.calls.ListPackageVersions
	mock.lockListPackageVersions.RUnlock()
	return calls
}

// ResetListPackageVersionsCalls reset all the calls that were made to ListPackageVersions.
func (mock *DataStoreQueriesStub) ResetListPackageVersionsCalls() {
	mock.lockListPackageVersions.Lock()
	mock.calls.ListPackageVersions = nil
	mock.lockListPackageVersions.Unlock()
}

// ListPackages calls ListPackagesFunc.
func (mock *DataStoreQueriesStub) ListPackages(ctx context.Context) ([]persister.Package, error) {
	if mock.ListPackagesFunc == nil {
		panic("DataStoreQueriesStub.ListPackagesFunc: method is nil but DataStoreQueries.ListPackages was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListPackages.Lock()
	mock.calls.ListPackages = append(mock.calls.ListPackages, callInfo)
	mock.lockListPackages.Unlock()
	return mock.ListPackagesFunc(ctx)
}

// ListPackagesCalls gets all the calls that were made to ListPackages.
// Check the length with:
//
//	len(mockedDataStoreQueries.ListPackagesCalls())
func (mock *DataStoreQueriesStub) ListPackagesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListPackages.RLock()
	calls = mock.calls.ListPackages
	mock.lockListPackages.RUnlock()
	return calls
}

// ResetListPackagesCalls reset all the calls that were made to ListPackages.
func (mock *DataStoreQueriesStub) ResetListPackagesCalls() {
	mock.lockListPackages.Lock()
	mock.calls.ListPackages = nil
	mock.lockListPackages.Unlock()
}

// ListProjects calls ListProjectsFunc.
func (mock *DataStoreQueriesStub) ListProjects(ctx context.Context) ([]persister.Project, error) {
	if mock.ListProjectsFunc == nil {
		panic("DataStoreQueriesStub.ListProjectsFunc: method is nil but DataStoreQueries.ListProjects was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListProjects.Lock()
	mock.calls.ListProjects = append(mock.calls.ListProjects, callInfo)
	mock.lockListProjects.Unlock()
	return mock.ListProjectsFunc(ctx)
}

// ListProjectsCalls gets all the calls that were made to ListProjects.
// Check the length with:
//
//	len(mockedDataStoreQueries.ListProjectsCalls())
func (mock *DataStoreQueriesStub) ListProjectsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListProjects.RLock()
	calls = mock.calls.ListProjects
	mock.lockListProjects.RUnlock()
	return calls
}

// ResetListProjectsCalls reset all the calls that were made to ListProjects.
func (mock *DataStoreQueriesStub) ResetListProjectsCalls() {
	mock.lockListProjects.Lock()
	mock.calls.ListProjects = nil
	mock.lockListProjects.Unlock()
}

// ListSurveyModules calls ListSurveyModulesFunc.
func (mock *DataStoreQueriesStub) ListSurveyModules(ctx context.Context) ([]persister.SurveyModule, error) {
	if mock.ListSurveyModulesFunc == nil {
		panic("DataStoreQueriesStub.ListSurveyModulesFunc: method is nil but DataStoreQueries.ListSurveyModules was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListSurveyModules.Lock()
	mock.calls.ListSurveyModules = append(mock.calls.ListSurveyModules, callInfo)
	mock.lockListSurveyModules.Unlock()
	return mock.ListSurveyModulesFunc(ctx)
}

// ListSurveyModulesCalls gets all the calls that were made to ListSurveyModules.
// Check the length with:
//
//	len(mockedDataStoreQueries.ListSurveyModulesCalls())
func (mock *DataStoreQueriesStub) ListSurveyModulesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListSurveyModules.RLock()
	calls = mock.calls.ListSurveyModules
	mock.lockListSurveyModules.RUnlock()
	return calls
}

// ResetListSurveyModulesCalls reset all the calls that were made to ListSurveyModules.
func (mock *DataStoreQueriesStub) ResetListSurveyModulesCalls() {
	mock.lockListSurveyModules.Lock()
	mock.calls.ListSurveyModules = nil
	mock.lockListSurveyModules.Unlock()
}

// ListSurveys calls ListSurveysFunc.
func (mock *DataStoreQueriesStub) ListSurveys(ctx context.Context) ([]persister.ListSurveysRow, error) {
	if mock.ListSurveysFunc == nil {
		panic("DataStoreQueriesStub.ListSurveysFunc: method is nil but DataStoreQueries.ListSurveys was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListSurveys.Lock()
	mock.calls.ListSurveys = append(mock.calls.ListSurveys, callInfo)
	mock.lockListSurveys.Unlock()
	return mock.ListSurveysFunc(ctx)
}

// ListSurveysCalls gets all the calls that were made to ListSurveys.
// Check the length with:
//
//	len(mockedDataStoreQueries.ListSurveysCalls())
func (mock *DataStoreQueriesStub) ListSurveysCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListSurveys.RLock()
	calls = mock.calls.ListSurveys
	mock.lockListSurveys.RUnlock()
	return calls
}

// ResetListSurveysCalls reset all the calls that were made to ListSurveys.
func (mock *DataStoreQueriesStub) ResetListSurveysCalls() {
	mock.lockListSurveys.Lock()
	mock.calls.ListSurveys = nil
	mock.lockListSurveys.Unlock()
}

// ListSymbolTypes calls ListSymbolTypesFunc.
func (mock *DataStoreQueriesStub) ListSymbolTypes(ctx context.Context) ([]persister.SymbolType, error) {
	if mock.ListSymbolTypesFunc == nil {
		panic("DataStoreQueriesStub.ListSymbolTypesFunc: method is nil but DataStoreQueries.ListSymbolTypes was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListSymbolTypes.Lock()
	mock.calls.ListSymbolTypes = append(mock.calls.ListSymbolTypes, callInfo)
	mock.lockListSymbolTypes.Unlock()
	return mock.ListSymbolTypesFunc(ctx)
}

// ListSymbolTypesCalls gets all the calls that were made to ListSymbolTypes.
// Check the length with:
//
//	len(mockedDataStoreQueries.ListSymbolTypesCalls())
func (mock *DataStoreQueriesStub) ListSymbolTypesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListSymbolTypes.RLock()
	calls = mock.calls.ListSymbolTypes
	mock.lockListSymbolTypes.RUnlock()
	return calls
}

// ResetListSymbolTypesCalls reset all the calls that were made to ListSymbolTypes.
func (mock *DataStoreQueriesStub) ResetListSymbolTypesCalls() {
	mock.lockListSymbolTypes.Lock()
	mock.calls.ListSymbolTypes = nil
	mock.lockListSymbolTypes.Unlock()
}

// ListSymbolTypesByName calls ListSymbolTypesByNameFunc.
func (mock *DataStoreQueriesStub) ListSymbolTypesByName(ctx context.Context) ([]persister.SymbolType, error) {
	if mock.ListSymbolTypesByNameFunc == nil {
		panic("DataStoreQueriesStub.ListSymbolTypesByNameFunc: method is nil but DataStoreQueries.ListSymbolTypesByName was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListSymbolTypesByName.Lock()
	mock.calls.ListSymbolTypesByName = append(mock.calls.ListSymbolTypesByName, callInfo)
	mock.lockListSymbolTypesByName.Unlock()
	return mock.ListSymbolTypesByNameFunc(ctx)
}

// ListSymbolTypesByNameCalls gets all the calls that were made to ListSymbolTypesByName.
// Check the length with:
//
//	len(mockedDataStoreQueries.ListSymbolTypesByNameCalls())
func (mock *DataStoreQueriesStub) ListSymbolTypesByNameCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListSymbolTypesByName.RLock()
	calls = mock.calls.ListSymbolTypesByName
	mock.lockListSymbolTypesByName.RUnlock()
	return calls
}

// ResetListSymbolTypesByNameCalls reset all the calls that were made to ListSymbolTypesByName.
func (mock *DataStoreQueriesStub) ResetListSymbolTypesByNameCalls() {
	mock.lockListSymbolTypesByName.Lock()
	mock.calls.ListSymbolTypesByName = nil
	mock.lockListSymbolTypesByName.Unlock()
}

// ListTypes calls ListTypesFunc.
func (mock *DataStoreQueriesStub) ListTypes(ctx context.Context) ([]persister.TypeView, error) {
	if mock.ListTypesFunc == nil {
		panic("DataStoreQueriesStub.ListTypesFunc: method is nil but DataStoreQueries.ListTypes was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListTypes.Lock()
	mock.calls.ListTypes = append(mock.calls.ListTypes, callInfo)
	mock.lockListTypes.Unlock()
	return mock.ListTypesFunc(ctx)
}

// ListTypesCalls gets all the calls that were made to ListTypes.
// Check the length with:
//
//	len(mockedDataStoreQueries.ListTypesCalls())
func (mock *DataStoreQueriesStub) ListTypesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListTypes.RLock()
	calls = mock.calls.ListTypes
	mock.lockListTypes.RUnlock()
	return calls
}

// ResetListTypesCalls reset all the calls that were made to ListTypes.
func (mock *DataStoreQueriesStub) ResetListTypesCalls() {
	mock.lockListTypes.Lock()
	mock.calls.ListTypes = nil
	mock.lockListTypes.Unlock()
}

// ListTypesByFile calls ListTypesByFileFunc.
func (mock *DataStoreQueriesStub) ListTypesByFile(ctx context.Context, fileID int64) ([]persister.TypeView, error) {
	if mock.ListTypesByFileFunc == nil {
		panic("DataStoreQueriesStub.ListTypesByFileFunc: method is nil but DataStoreQueries.ListTypesByFile was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		FileID int64
	}{
		Ctx:    ctx,
		FileID: fileID,
	}
	mock.lockListTypesByFile.Lock()
	mock.calls.ListTypesByFile = append(mock.calls.ListTypesByFile, callInfo)
	mock.lockListTypesByFile.Unlock()
	return mock.ListTypesByFileFunc(ctx, fileID)
}

// ListTypesByFileCalls gets all the calls that were made to ListTypesByFile.
// Check the length with:
//
//	len(mockedDataStoreQueries.ListTypesByFileCalls())
func (mock *DataStoreQueriesStub) ListTypesByFileCalls() []struct {
	Ctx    context.Context
	FileID int64
} {
	var calls []struct {
		Ctx    context.Context
		FileID int64
	}
	mock.lockListTypesByFile.RLock()
	calls = mock.calls.ListTypesByFile
	mock.lockListTypesByFile.RUnlock()
	return calls
}

// ResetListTypesByFileCalls reset all the calls that were made to ListTypesByFile.
func (mock *DataStoreQueriesStub) ResetListTypesByFileCalls() {
	mock.lockListTypesByFile.Lock()
	mock.calls.ListTypesByFile = nil
	mock.lockListTypesByFile.Unlock()
}

// ListTypesBySurvey calls ListTypesBySurveyFunc.
func (mock *DataStoreQueriesStub) ListTypesBySurvey(ctx context.Context, surveyID int64) ([]persister.TypeView, error) {
	if mock.ListTypesBySurveyFunc == nil {
		panic("DataStoreQueriesStub.ListTypesBySurveyFunc: method is nil but DataStoreQueries.ListTypesBySurvey was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		SurveyID int64
	}{
		Ctx:      ctx,
		SurveyID: surveyID,
	}
	mock.lockListTypesBySurvey.Lock()
	mock.calls.ListTypesBySurvey = append(mock.calls.ListTypesBySurvey, callInfo)
	mock.lockListTypesBySurvey.Unlock()
	return mock.ListTypesBySurveyFunc(ctx, surveyID)
}

// ListTypesBySurveyCalls gets all the calls that were made to ListTypesBySurvey.
// Check the length with:
//
//	len(mockedDataStoreQueries.ListTypesBySurveyCalls())
func (mock *DataStoreQueriesStub) ListTypesBySurveyCalls() []struct {
	Ctx      context.Context
	SurveyID int64
} {
	var calls []struct {
		Ctx      context.Context
		SurveyID int64
	}
	mock.lockListTypesBySurvey.RLock()
	calls = mock.calls.ListTypesBySurvey
	mock.lockListTypesBySurvey.RUnlock()
	return calls
}

// ResetListTypesBySurveyCalls reset all the calls that were made to ListTypesBySurvey.
func (mock *DataStoreQueriesStub) ResetListTypesBySurveyCalls() {
	mock.lockListTypesBySurvey.Lock()
	mock.calls.ListTypesBySurvey = nil
	mock.lockListTypesBySurvey.Unlock()
}

// ListVariables calls ListVariablesFunc.
func (mock *DataStoreQueriesStub) ListVariables(ctx context.Context) ([]persister.Variable, error) {
	if mock.ListVariablesFunc == nil {
		panic("DataStoreQueriesStub.ListVariablesFunc: method is nil but DataStoreQueries.ListVariables was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListVariables.Lock()
	mock.calls.ListVariables = append(mock.calls.ListVariables, callInfo)
	mock.lockListVariables.Unlock()
	return mock.ListVariablesFunc(ctx)
}

// ListVariablesCalls gets all the calls that were made to ListVariables.
// Check the length with:
//
//	len(mockedDataStoreQueries.ListVariablesCalls())
func (mock *DataStoreQueriesStub) ListVariablesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListVariables.RLock()
	calls = mock.calls.ListVariables
	mock.lockListVariables.RUnlock()
	return calls
}

// ResetListVariablesCalls reset all the calls that were made to ListVariables.
func (mock *DataStoreQueriesStub) ResetListVariablesCalls() {
	mock.lockListVariables.Lock()
	mock.calls.ListVariables = nil
	mock.lockListVariables.Unlock()
}

// LoadCategory calls LoadCategoryFunc.
func (mock *DataStoreQueriesStub) LoadCategory(ctx context.Context, id int64) (persister.Category, error) {
	if mock.LoadCategoryFunc == nil {
		panic("DataStoreQueriesStub.LoadCategoryFunc: method is nil but DataStoreQueries.LoadCategory was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockLoadCategory.Lock()
	mock.calls.LoadCategory = append(mock.calls.LoadCategory, callInfo)
	mock.lockLoadCategory.Unlock()
	return mock.LoadCategoryFunc(ctx, id)
}

// LoadCategoryCalls gets all the calls that were made to LoadCategory.
// Check the length with:
//
//	len(mockedDataStoreQueries.LoadCategoryCalls())
func (mock *DataStoreQueriesStub) LoadCategoryCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockLoadCategory.RLock()
	calls = mock.calls.LoadCategory
	mock.lockLoadCategory.RUnlock()
	return calls
}

// ResetLoadCategoryCalls reset all the calls that were made to LoadCategory.
func (mock *DataStoreQueriesStub) ResetLoadCategoryCalls() {
	mock.lockLoadCategory.Lock()
	mock.calls.LoadCategory = nil
	mock.lockLoadCategory.Unlock()
}

// LoadCodebase calls LoadCodebaseFunc.
func (mock *DataStoreQueriesStub) LoadCodebase(ctx context.Context, id int64) (persister.Codebase, error) {
	if mock.LoadCodebaseFunc == nil {
		panic("DataStoreQueriesStub.LoadCodebaseFunc: method is nil but DataStoreQueries.LoadCodebase was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockLoadCodebase.Lock()
	mock.calls.LoadCodebase = append(mock.calls.LoadCodebase, callInfo)
	mock.lockLoadCodebase.Unlock()
	return mock.LoadCodebaseFunc(ctx, id)
}

// LoadCodebaseCalls gets all the calls that were made to LoadCodebase.
// Check the length with:
//
//	len(mockedDataStoreQueries.LoadCodebaseCalls())
func (mock *DataStoreQueriesStub) LoadCodebaseCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockLoadCodebase.RLock()
	calls = mock.calls.LoadCodebase
	mock.lockLoadCodebase.RUnlock()
	return calls
}

// ResetLoadCodebaseCalls reset all the calls that were made to LoadCodebase.
func (mock *DataStoreQueriesStub) ResetLoadCodebaseCalls() {
	mock.lockLoadCodebase.Lock()
	mock.calls.LoadCodebase = nil
	mock.lockLoadCodebase.Unlock()
}

// LoadCodebaseIDByProjectAndVersion calls LoadCodebaseIDByProjectAndVersionFunc.
func (mock *DataStoreQueriesStub) LoadCodebaseIDByProjectAndVersion(ctx context.Context, arg persister.LoadCodebaseIDByProjectAndVersionParams) (int64, error) {
	if mock.LoadCodebaseIDByProjectAndVersionFunc == nil {
		panic("DataStoreQueriesStub.LoadCodebaseIDByProjectAndVersionFunc: method is nil but DataStoreQueries.LoadCodebaseIDByProjectAndVersion was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.LoadCodebaseIDByProjectAndVersionParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockLoadCodebaseIDByProjectAndVersion.Lock()
	mock.calls.LoadCodebaseIDByProjectAndVersion = append(mock.calls.LoadCodebaseIDByProjectAndVersion, callInfo)
	mock.lockLoadCodebaseIDByProjectAndVersion.Unlock()
	return mock.LoadCodebaseIDByProjectAndVersionFunc(ctx, arg)
}

// LoadCodebaseIDByProjectAndVersionCalls gets all the calls that were made to LoadCodebaseIDByProjectAndVersion.
// Check the length with:
//
//	len(mockedDataStoreQueries.LoadCodebaseIDByProjectAndVersionCalls())
func (mock *DataStoreQueriesStub) LoadCodebaseIDByProjectAndVersionCalls() []struct {
	Ctx context.Context
	Arg persister.LoadCodebaseIDByProjectAndVersionParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.LoadCodebaseIDByProjectAndVersionParams
	}
	mock.lockLoadCodebaseIDByProjectAndVersion.RLock()
	calls = mock.calls.LoadCodebaseIDByProjectAndVersion
	mock.lockLoadCodebaseIDByProjectAndVersion.RUnlock()
	return calls
}

// ResetLoadCodebaseIDByProjectAndVersionCalls reset all the calls that were made to LoadCodebaseIDByProjectAndVersion.
func (mock *DataStoreQueriesStub) ResetLoadCodebaseIDByProjectAndVersionCalls() {
	mock.lockLoadCodebaseIDByProjectAndVersion.Lock()
	mock.calls.LoadCodebaseIDByProjectAndVersion = nil
	mock.lockLoadCodebaseIDByProjectAndVersion.Unlock()
}

// LoadCodebaseIdByRepoURL calls LoadCodebaseIdByRepoURLFunc.
func (mock *DataStoreQueriesStub) LoadCodebaseIdByRepoURL(ctx context.Context, repoUrl string) (int64, error) {
	if mock.LoadCodebaseIdByRepoURLFunc == nil {
		panic("DataStoreQueriesStub.LoadCodebaseIdByRepoURLFunc: method is nil but DataStoreQueries.LoadCodebaseIdByRepoURL was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		RepoUrl string
	}{
		Ctx:     ctx,
		RepoUrl: repoUrl,
	}
	mock.lockLoadCodebaseIdByRepoURL.Lock()
	mock.calls.LoadCodebaseIdByRepoURL = append(mock.calls.LoadCodebaseIdByRepoURL, callInfo)
	mock.lockLoadCodebaseIdByRepoURL.Unlock()
	return mock.LoadCodebaseIdByRepoURLFunc(ctx, repoUrl)
}

// LoadCodebaseIdByRepoURLCalls gets all the calls that were made to LoadCodebaseIdByRepoURL.
// Check the length with:
//
//	len(mockedDataStoreQueries.LoadCodebaseIdByRepoURLCalls())
func (mock *DataStoreQueriesStub) LoadCodebaseIdByRepoURLCalls() []struct {
	Ctx     context.Context
	RepoUrl string
} {
	var calls []struct {
		Ctx     context.Context
		RepoUrl string
	}
	mock.lockLoadCodebaseIdByRepoURL.RLock()
	calls = mock.calls.LoadCodebaseIdByRepoURL
	mock.lockLoadCodebaseIdByRepoURL.RUnlock()
	return calls
}

// ResetLoadCodebaseIdByRepoURLCalls reset all the calls that were made to LoadCodebaseIdByRepoURL.
func (mock *DataStoreQueriesStub) ResetLoadCodebaseIdByRepoURLCalls() {
	mock.lockLoadCodebaseIdByRepoURL.Lock()
	mock.calls.LoadCodebaseIdByRepoURL = nil
	mock.lockLoadCodebaseIdByRepoURL.Unlock()
}

// LoadFile calls LoadFileFunc.
func (mock *DataStoreQueriesStub) LoadFile(ctx context.Context, id int64) (persister.File, error) {
	if mock.LoadFileFunc == nil {
		panic("DataStoreQueriesStub.LoadFileFunc: method is nil but DataStoreQueries.LoadFile was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockLoadFile.Lock()
	mock.calls.LoadFile = append(mock.calls.LoadFile, callInfo)
	mock.lockLoadFile.Unlock()
	return mock.LoadFileFunc(ctx, id)
}

// LoadFileCalls gets all the calls that were made to LoadFile.
// Check the length with:
//
//	len(mockedDataStoreQueries.LoadFileCalls())
func (mock *DataStoreQueriesStub) LoadFileCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockLoadFile.RLock()
	calls = mock.calls.LoadFile
	mock.lockLoadFile.RUnlock()
	return calls
}

// ResetLoadFileCalls reset all the calls that were made to LoadFile.
func (mock *DataStoreQueriesStub) ResetLoadFileCalls() {
	mock.lockLoadFile.Lock()
	mock.calls.LoadFile = nil
	mock.lockLoadFile.Unlock()
}

// LoadImport calls LoadImportFunc.
func (mock *DataStoreQueriesStub) LoadImport(ctx context.Context, id int64) (persister.Import, error) {
	if mock.LoadImportFunc == nil {
		panic("DataStoreQueriesStub.LoadImportFunc: method is nil but DataStoreQueries.LoadImport was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockLoadImport.Lock()
	mock.calls.LoadImport = append(mock.calls.LoadImport, callInfo)
	mock.lockLoadImport.Unlock()
	return mock.LoadImportFunc(ctx, id)
}

// LoadImportCalls gets all the calls that were made to LoadImport.
// Check the length with:
//
//	len(mockedDataStoreQueries.LoadImportCalls())
func (mock *DataStoreQueriesStub) LoadImportCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockLoadImport.RLock()
	calls = mock.calls.LoadImport
	mock.lockLoadImport.RUnlock()
	return calls
}

// ResetLoadImportCalls reset all the calls that were made to LoadImport.
func (mock *DataStoreQueriesStub) ResetLoadImportCalls() {
	mock.lockLoadImport.Lock()
	mock.calls.LoadImport = nil
	mock.lockLoadImport.Unlock()
}

// LoadMethod calls LoadMethodFunc.
func (mock *DataStoreQueriesStub) LoadMethod(ctx context.Context, id int64) (persister.Method, error) {
	if mock.LoadMethodFunc == nil {
		panic("DataStoreQueriesStub.LoadMethodFunc: method is nil but DataStoreQueries.LoadMethod was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockLoadMethod.Lock()
	mock.calls.LoadMethod = append(mock.calls.LoadMethod, callInfo)
	mock.lockLoadMethod.Unlock()
	return mock.LoadMethodFunc(ctx, id)
}

// LoadMethodCalls gets all the calls that were made to LoadMethod.
// Check the length with:
//
//	len(mockedDataStoreQueries.LoadMethodCalls())
func (mock *DataStoreQueriesStub) LoadMethodCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockLoadMethod.RLock()
	calls = mock.calls.LoadMethod
	mock.lockLoadMethod.RUnlock()
	return calls
}

// ResetLoadMethodCalls reset all the calls that were made to LoadMethod.
func (mock *DataStoreQueriesStub) ResetLoadMethodCalls() {
	mock.lockLoadMethod.Lock()
	mock.calls.LoadMethod = nil
	mock.lockLoadMethod.Unlock()
}

// LoadModule calls LoadModuleFunc.
func (mock *DataStoreQueriesStub) LoadModule(ctx context.Context, id int64) (persister.Module, error) {
	if mock.LoadModuleFunc == nil {
		panic("DataStoreQueriesStub.LoadModuleFunc: method is nil but DataStoreQueries.LoadModule was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockLoadModule.Lock()
	mock.calls.LoadModule = append(mock.calls.LoadModule, callInfo)
	mock.lockLoadModule.Unlock()
	return mock.LoadModuleFunc(ctx, id)
}

// LoadModuleCalls gets all the calls that were made to LoadModule.
// Check the length with:
//
//	len(mockedDataStoreQueries.LoadModuleCalls())
func (mock *DataStoreQueriesStub) LoadModuleCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockLoadModule.RLock()
	calls = mock.calls.LoadModule
	mock.lockLoadModule.RUnlock()
	return calls
}

// ResetLoadModuleCalls reset all the calls that were made to LoadModule.
func (mock *DataStoreQueriesStub) ResetLoadModuleCalls() {
	mock.lockLoadModule.Lock()
	mock.calls.LoadModule = nil
	mock.lockLoadModule.Unlock()
}

// LoadModuleVersion calls LoadModuleVersionFunc.
func (mock *DataStoreQueriesStub) LoadModuleVersion(ctx context.Context, id int64) (persister.ModuleVersion, error) {
	if mock.LoadModuleVersionFunc == nil {
		panic("DataStoreQueriesStub.LoadModuleVersionFunc: method is nil but DataStoreQueries.LoadModuleVersion was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockLoadModuleVersion.Lock()
	mock.calls.LoadModuleVersion = append(mock.calls.LoadModuleVersion, callInfo)
	mock.lockLoadModuleVersion.Unlock()
	return mock.LoadModuleVersionFunc(ctx, id)
}

// LoadModuleVersionCalls gets all the calls that were made to LoadModuleVersion.
// Check the length with:
//
//	len(mockedDataStoreQueries.LoadModuleVersionCalls())
func (mock *DataStoreQueriesStub) LoadModuleVersionCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockLoadModuleVersion.RLock()
	calls = mock.calls.LoadModuleVersion
	mock.lockLoadModuleVersion.RUnlock()
	return calls
}

// ResetLoadModuleVersionCalls reset all the calls that were made to LoadModuleVersion.
func (mock *DataStoreQueriesStub) ResetLoadModuleVersionCalls() {
	mock.lockLoadModuleVersion.Lock()
	mock.calls.LoadModuleVersion = nil
	mock.lockLoadModuleVersion.Unlock()
}

// LoadPackage calls LoadPackageFunc.
func (mock *DataStoreQueriesStub) LoadPackage(ctx context.Context, id int64) (persister.Package, error) {
	if mock.LoadPackageFunc == nil {
		panic("DataStoreQueriesStub.LoadPackageFunc: method is nil but DataStoreQueries.LoadPackage was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockLoadPackage.Lock()
	mock.calls.LoadPackage = append(mock.calls.LoadPackage, callInfo)
	mock.lockLoadPackage.Unlock()
	return mock.LoadPackageFunc(ctx, id)
}

// LoadPackageCalls gets all the calls that were made to LoadPackage.
// Check the length with:
//
//	len(mockedDataStoreQueries.LoadPackageCalls())
func (mock *DataStoreQueriesStub) LoadPackageCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockLoadPackage.RLock()
	calls = mock.calls.LoadPackage
	mock.lockLoadPackage.RUnlock()
	return calls
}

// ResetLoadPackageCalls reset all the calls that were made to LoadPackage.
func (mock *DataStoreQueriesStub) ResetLoadPackageCalls() {
	mock.lockLoadPackage.Lock()
	mock.calls.LoadPackage = nil
	mock.lockLoadPackage.Unlock()
}

// LoadPackageType calls LoadPackageTypeFunc.
func (mock *DataStoreQueriesStub) LoadPackageType(ctx context.Context, id int64) (persister.PackageType, error) {
	if mock.LoadPackageTypeFunc == nil {
		panic("DataStoreQueriesStub.LoadPackageTypeFunc: method is nil but DataStoreQueries.LoadPackageType was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockLoadPackageType.Lock()
	mock.calls.LoadPackageType = append(mock.calls.LoadPackageType, callInfo)
	mock.lockLoadPackageType.Unlock()
	return mock.LoadPackageTypeFunc(ctx, id)
}

// LoadPackageTypeCalls gets all the calls that were made to LoadPackageType.
// Check the length with:
//
//	len(mockedDataStoreQueries.LoadPackageTypeCalls())
func (mock *DataStoreQueriesStub) LoadPackageTypeCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockLoadPackageType.RLock()
	calls = mock.calls.LoadPackageType
	mock.lockLoadPackageType.RUnlock()
	return calls
}

// ResetLoadPackageTypeCalls reset all the calls that were made to LoadPackageType.
func (mock *DataStoreQueriesStub) ResetLoadPackageTypeCalls() {
	mock.lockLoadPackageType.Lock()
	mock.calls.LoadPackageType = nil
	mock.lockLoadPackageType.Unlock()
}

// LoadPackageVersion calls LoadPackageVersionFunc.
func (mock *DataStoreQueriesStub) LoadPackageVersion(ctx context.Context, id int64) (persister.PackageVersion, error) {
	if mock.LoadPackageVersionFunc == nil {
		panic("DataStoreQueriesStub.LoadPackageVersionFunc: method is nil but DataStoreQueries.LoadPackageVersion was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockLoadPackageVersion.Lock()
	mock.calls.LoadPackageVersion = append(mock.calls.LoadPackageVersion, callInfo)
	mock.lockLoadPackageVersion.Unlock()
	return mock.LoadPackageVersionFunc(ctx, id)
}

// LoadPackageVersionCalls gets all the calls that were made to LoadPackageVersion.
// Check the length with:
//
//	len(mockedDataStoreQueries.LoadPackageVersionCalls())
func (mock *DataStoreQueriesStub) LoadPackageVersionCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockLoadPackageVersion.RLock()
	calls = mock.calls.LoadPackageVersion
	mock.lockLoadPackageVersion.RUnlock()
	return calls
}

// ResetLoadPackageVersionCalls reset all the calls that were made to LoadPackageVersion.
func (mock *DataStoreQueriesStub) ResetLoadPackageVersionCalls() {
	mock.lockLoadPackageVersion.Lock()
	mock.calls.LoadPackageVersion = nil
	mock.lockLoadPackageVersion.Unlock()
}

// LoadProject calls LoadProjectFunc.
func (mock *DataStoreQueriesStub) LoadProject(ctx context.Context, id int64) (persister.Project, error) {
	if mock.LoadProjectFunc == nil {
		panic("DataStoreQueriesStub.LoadProjectFunc: method is nil but DataStoreQueries.LoadProject was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockLoadProject.Lock()
	mock.calls.LoadProject = append(mock.calls.LoadProject, callInfo)
	mock.lockLoadProject.Unlock()
	return mock.LoadProjectFunc(ctx, id)
}

// LoadProjectCalls gets all the calls that were made to LoadProject.
// Check the length with:
//
//	len(mockedDataStoreQueries.LoadProjectCalls())
func (mock *DataStoreQueriesStub) LoadProjectCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockLoadProject.RLock()
	calls = mock.calls.LoadProject
	mock.lockLoadProject.RUnlock()
	return calls
}

// ResetLoadProjectCalls reset all the calls that were made to LoadProject.
func (mock *DataStoreQueriesStub) ResetLoadProjectCalls() {
	mock.lockLoadProject.Lock()
	mock.calls.LoadProject = nil
	mock.lockLoadProject.Unlock()
}

// LoadProjectByName calls LoadProjectByNameFunc.
func (mock *DataStoreQueriesStub) LoadProjectByName(ctx context.Context, name string) (persister.Project, error) {
	if mock.LoadProjectByNameFunc == nil {
		panic("DataStoreQueriesStub.LoadProjectByNameFunc: method is nil but DataStoreQueries.LoadProjectByName was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockLoadProjectByName.Lock()
	mock.calls.LoadProjectByName = append(mock.calls.LoadProjectByName, callInfo)
	mock.lockLoadProjectByName.Unlock()
	return mock.LoadProjectByNameFunc(ctx, name)
}

// LoadProjectByNameCalls gets all the calls that were made to LoadProjectByName.
// Check the length with:
//
//	len(mockedDataStoreQueries.LoadProjectByNameCalls())
func (mock *DataStoreQueriesStub) LoadProjectByNameCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockLoadProjectByName.RLock()
	calls = mock.calls.LoadProjectByName
	mock.lockLoadProjectByName.RUnlock()
	return calls
}

// ResetLoadProjectByNameCalls reset all the calls that were made to LoadProjectByName.
func (mock *DataStoreQueriesStub) ResetLoadProjectByNameCalls() {
	mock.lockLoadProjectByName.Lock()
	mock.calls.LoadProjectByName = nil
	mock.lockLoadProjectByName.Unlock()
}

// LoadProjectByRepoURL calls LoadProjectByRepoURLFunc.
func (mock *DataStoreQueriesStub) LoadProjectByRepoURL(ctx context.Context, repoUrl string) (persister.Project, error) {
	if mock.LoadProjectByRepoURLFunc == nil {
		panic("DataStoreQueriesStub.LoadProjectByRepoURLFunc: method is nil but DataStoreQueries.LoadProjectByRepoURL was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		RepoUrl string
	}{
		Ctx:     ctx,
		RepoUrl: repoUrl,
	}
	mock.lockLoadProjectByRepoURL.Lock()
	mock.calls.LoadProjectByRepoURL = append(mock.calls.LoadProjectByRepoURL, callInfo)
	mock.lockLoadProjectByRepoURL.Unlock()
	return mock.LoadProjectByRepoURLFunc(ctx, repoUrl)
}

// LoadProjectByRepoURLCalls gets all the calls that were made to LoadProjectByRepoURL.
// Check the length with:
//
//	len(mockedDataStoreQueries.LoadProjectByRepoURLCalls())
func (mock *DataStoreQueriesStub) LoadProjectByRepoURLCalls() []struct {
	Ctx     context.Context
	RepoUrl string
} {
	var calls []struct {
		Ctx     context.Context
		RepoUrl string
	}
	mock.lockLoadProjectByRepoURL.RLock()
	calls = mock.calls.LoadProjectByRepoURL
	mock.lockLoadProjectByRepoURL.RUnlock()
	return calls
}

// ResetLoadProjectByRepoURLCalls reset all the calls that were made to LoadProjectByRepoURL.
func (mock *DataStoreQueriesStub) ResetLoadProjectByRepoURLCalls() {
	mock.lockLoadProjectByRepoURL.Lock()
	mock.calls.LoadProjectByRepoURL = nil
	mock.lockLoadProjectByRepoURL.Unlock()
}

// LoadProjectRepoURL calls LoadProjectRepoURLFunc.
func (mock *DataStoreQueriesStub) LoadProjectRepoURL(ctx context.Context, id int64) (string, error) {
	if mock.LoadProjectRepoURLFunc == nil {
		panic("DataStoreQueriesStub.LoadProjectRepoURLFunc: method is nil but DataStoreQueries.LoadProjectRepoURL was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockLoadProjectRepoURL.Lock()
	mock.calls.LoadProjectRepoURL = append(mock.calls.LoadProjectRepoURL, callInfo)
	mock.lockLoadProjectRepoURL.Unlock()
	return mock.LoadProjectRepoURLFunc(ctx, id)
}

// LoadProjectRepoURLCalls gets all the calls that were made to LoadProjectRepoURL.
// Check the length with:
//
//	len(mockedDataStoreQueries.LoadProjectRepoURLCalls())
func (mock *DataStoreQueriesStub) LoadProjectRepoURLCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockLoadProjectRepoURL.RLock()
	calls = mock.calls.LoadProjectRepoURL
	mock.lockLoadProjectRepoURL.RUnlock()
	return calls
}

// ResetLoadProjectRepoURLCalls reset all the calls that were made to LoadProjectRepoURL.
func (mock *DataStoreQueriesStub) ResetLoadProjectRepoURLCalls() {
	mock.lockLoadProjectRepoURL.Lock()
	mock.calls.LoadProjectRepoURL = nil
	mock.lockLoadProjectRepoURL.Unlock()
}

// LoadSurvey calls LoadSurveyFunc.
func (mock *DataStoreQueriesStub) LoadSurvey(ctx context.Context, id int64) (persister.Survey, error) {
	if mock.LoadSurveyFunc == nil {
		panic("DataStoreQueriesStub.LoadSurveyFunc: method is nil but DataStoreQueries.LoadSurvey was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockLoadSurvey.Lock()
	mock.calls.LoadSurvey = append(mock.calls.LoadSurvey, callInfo)
	mock.lockLoadSurvey.Unlock()
	return mock.LoadSurveyFunc(ctx, id)
}

// LoadSurveyCalls gets all the calls that were made to LoadSurvey.
// Check the length with:
//
//	len(mockedDataStoreQueries.LoadSurveyCalls())
func (mock *DataStoreQueriesStub) LoadSurveyCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockLoadSurvey.RLock()
	calls = mock.calls.LoadSurvey
	mock.lockLoadSurvey.RUnlock()
	return calls
}

// ResetLoadSurveyCalls reset all the calls that were made to LoadSurvey.
func (mock *DataStoreQueriesStub) ResetLoadSurveyCalls() {
	mock.lockLoadSurvey.Lock()
	mock.calls.LoadSurvey = nil
	mock.lockLoadSurvey.Unlock()
}

// LoadSurveyByRepoURL calls LoadSurveyByRepoURLFunc.
func (mock *DataStoreQueriesStub) LoadSurveyByRepoURL(ctx context.Context, repoUrl string) (persister.LoadSurveyByRepoURLRow, error) {
	if mock.LoadSurveyByRepoURLFunc == nil {
		panic("DataStoreQueriesStub.LoadSurveyByRepoURLFunc: method is nil but DataStoreQueries.LoadSurveyByRepoURL was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		RepoUrl string
	}{
		Ctx:     ctx,
		RepoUrl: repoUrl,
	}
	mock.lockLoadSurveyByRepoURL.Lock()
	mock.calls.LoadSurveyByRepoURL = append(mock.calls.LoadSurveyByRepoURL, callInfo)
	mock.lockLoadSurveyByRepoURL.Unlock()
	return mock.LoadSurveyByRepoURLFunc(ctx, repoUrl)
}

// LoadSurveyByRepoURLCalls gets all the calls that were made to LoadSurveyByRepoURL.
// Check the length with:
//
//	len(mockedDataStoreQueries.LoadSurveyByRepoURLCalls())
func (mock *DataStoreQueriesStub) LoadSurveyByRepoURLCalls() []struct {
	Ctx     context.Context
	RepoUrl string
} {
	var calls []struct {
		Ctx     context.Context
		RepoUrl string
	}
	mock.lockLoadSurveyByRepoURL.RLock()
	calls = mock.calls.LoadSurveyByRepoURL
	mock.lockLoadSurveyByRepoURL.RUnlock()
	return calls
}

// ResetLoadSurveyByRepoURLCalls reset all the calls that were made to LoadSurveyByRepoURL.
func (mock *DataStoreQueriesStub) ResetLoadSurveyByRepoURLCalls() {
	mock.lockLoadSurveyByRepoURL.Lock()
	mock.calls.LoadSurveyByRepoURL = nil
	mock.lockLoadSurveyByRepoURL.Unlock()
}

// LoadSurveyModule calls LoadSurveyModuleFunc.
func (mock *DataStoreQueriesStub) LoadSurveyModule(ctx context.Context, id int64) (persister.SurveyModule, error) {
	if mock.LoadSurveyModuleFunc == nil {
		panic("DataStoreQueriesStub.LoadSurveyModuleFunc: method is nil but DataStoreQueries.LoadSurveyModule was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockLoadSurveyModule.Lock()
	mock.calls.LoadSurveyModule = append(mock.calls.LoadSurveyModule, callInfo)
	mock.lockLoadSurveyModule.Unlock()
	return mock.LoadSurveyModuleFunc(ctx, id)
}

// LoadSurveyModuleCalls gets all the calls that were made to LoadSurveyModule.
// Check the length with:
//
//	len(mockedDataStoreQueries.LoadSurveyModuleCalls())
func (mock *DataStoreQueriesStub) LoadSurveyModuleCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockLoadSurveyModule.RLock()
	calls = mock.calls.LoadSurveyModule
	mock.lockLoadSurveyModule.RUnlock()
	return calls
}

// ResetLoadSurveyModuleCalls reset all the calls that were made to LoadSurveyModule.
func (mock *DataStoreQueriesStub) ResetLoadSurveyModuleCalls() {
	mock.lockLoadSurveyModule.Lock()
	mock.calls.LoadSurveyModule = nil
	mock.lockLoadSurveyModule.Unlock()
}

// LoadSymbolType calls LoadSymbolTypeFunc.
func (mock *DataStoreQueriesStub) LoadSymbolType(ctx context.Context, id int64) (persister.SymbolType, error) {
	if mock.LoadSymbolTypeFunc == nil {
		panic("DataStoreQueriesStub.LoadSymbolTypeFunc: method is nil but DataStoreQueries.LoadSymbolType was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockLoadSymbolType.Lock()
	mock.calls.LoadSymbolType = append(mock.calls.LoadSymbolType, callInfo)
	mock.lockLoadSymbolType.Unlock()
	return mock.LoadSymbolTypeFunc(ctx, id)
}

// LoadSymbolTypeCalls gets all the calls that were made to LoadSymbolType.
// Check the length with:
//
//	len(mockedDataStoreQueries.LoadSymbolTypeCalls())
func (mock *DataStoreQueriesStub) LoadSymbolTypeCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockLoadSymbolType.RLock()
	calls = mock.calls.LoadSymbolType
	mock.lockLoadSymbolType.RUnlock()
	return calls
}

// ResetLoadSymbolTypeCalls reset all the calls that were made to LoadSymbolType.
func (mock *DataStoreQueriesStub) ResetLoadSymbolTypeCalls() {
	mock.lockLoadSymbolType.Lock()
	mock.calls.LoadSymbolType = nil
	mock.lockLoadSymbolType.Unlock()
}

// LoadType calls LoadTypeFunc.
func (mock *DataStoreQueriesStub) LoadType(ctx context.Context, id int64) (persister.Type, error) {
	if mock.LoadTypeFunc == nil {
		panic("DataStoreQueriesStub.LoadTypeFunc: method is nil but DataStoreQueries.LoadType was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockLoadType.Lock()
	mock.calls.LoadType = append(mock.calls.LoadType, callInfo)
	mock.lockLoadType.Unlock()
	return mock.LoadTypeFunc(ctx, id)
}

// LoadTypeCalls gets all the calls that were made to LoadType.
// Check the length with:
//
//	len(mockedDataStoreQueries.LoadTypeCalls())
func (mock *DataStoreQueriesStub) LoadTypeCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockLoadType.RLock()
	calls = mock.calls.LoadType
	mock.lockLoadType.RUnlock()
	return calls
}

// ResetLoadTypeCalls reset all the calls that were made to LoadType.
func (mock *DataStoreQueriesStub) ResetLoadTypeCalls() {
	mock.lockLoadType.Lock()
	mock.calls.LoadType = nil
	mock.lockLoadType.Unlock()
}

// LoadVariable calls LoadVariableFunc.
func (mock *DataStoreQueriesStub) LoadVariable(ctx context.Context, id int64) (persister.Variable, error) {
	if mock.LoadVariableFunc == nil {
		panic("DataStoreQueriesStub.LoadVariableFunc: method is nil but DataStoreQueries.LoadVariable was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockLoadVariable.Lock()
	mock.calls.LoadVariable = append(mock.calls.LoadVariable, callInfo)
	mock.lockLoadVariable.Unlock()
	return mock.LoadVariableFunc(ctx, id)
}

// LoadVariableCalls gets all the calls that were made to LoadVariable.
// Check the length with:
//
//	len(mockedDataStoreQueries.LoadVariableCalls())
func (mock *DataStoreQueriesStub) LoadVariableCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockLoadVariable.RLock()
	calls = mock.calls.LoadVariable
	mock.lockLoadVariable.RUnlock()
	return calls
}

// ResetLoadVariableCalls reset all the calls that were made to LoadVariable.
func (mock *DataStoreQueriesStub) ResetLoadVariableCalls() {
	mock.lockLoadVariable.Lock()
	mock.calls.LoadVariable = nil
	mock.lockLoadVariable.Unlock()
}

// UpdateCategory calls UpdateCategoryFunc.
func (mock *DataStoreQueriesStub) UpdateCategory(ctx context.Context, arg persister.UpdateCategoryParams) error {
	if mock.UpdateCategoryFunc == nil {
		panic("DataStoreQueriesStub.UpdateCategoryFunc: method is nil but DataStoreQueries.UpdateCategory was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpdateCategoryParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdateCategory.Lock()
	mock.calls.UpdateCategory = append(mock.calls.UpdateCategory, callInfo)
	mock.lockUpdateCategory.Unlock()
	return mock.UpdateCategoryFunc(ctx, arg)
}

// UpdateCategoryCalls gets all the calls that were made to UpdateCategory.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpdateCategoryCalls())
func (mock *DataStoreQueriesStub) UpdateCategoryCalls() []struct {
	Ctx context.Context
	Arg persister.UpdateCategoryParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpdateCategoryParams
	}
	mock.lockUpdateCategory.RLock()
	calls = mock.calls.UpdateCategory
	mock.lockUpdateCategory.RUnlock()
	return calls
}

// ResetUpdateCategoryCalls reset all the calls that were made to UpdateCategory.
func (mock *DataStoreQueriesStub) ResetUpdateCategoryCalls() {
	mock.lockUpdateCategory.Lock()
	mock.calls.UpdateCategory = nil
	mock.lockUpdateCategory.Unlock()
}

// UpdateCodebase calls UpdateCodebaseFunc.
func (mock *DataStoreQueriesStub) UpdateCodebase(ctx context.Context, arg persister.UpdateCodebaseParams) error {
	if mock.UpdateCodebaseFunc == nil {
		panic("DataStoreQueriesStub.UpdateCodebaseFunc: method is nil but DataStoreQueries.UpdateCodebase was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpdateCodebaseParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdateCodebase.Lock()
	mock.calls.UpdateCodebase = append(mock.calls.UpdateCodebase, callInfo)
	mock.lockUpdateCodebase.Unlock()
	return mock.UpdateCodebaseFunc(ctx, arg)
}

// UpdateCodebaseCalls gets all the calls that were made to UpdateCodebase.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpdateCodebaseCalls())
func (mock *DataStoreQueriesStub) UpdateCodebaseCalls() []struct {
	Ctx context.Context
	Arg persister.UpdateCodebaseParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpdateCodebaseParams
	}
	mock.lockUpdateCodebase.RLock()
	calls = mock.calls.UpdateCodebase
	mock.lockUpdateCodebase.RUnlock()
	return calls
}

// ResetUpdateCodebaseCalls reset all the calls that were made to UpdateCodebase.
func (mock *DataStoreQueriesStub) ResetUpdateCodebaseCalls() {
	mock.lockUpdateCodebase.Lock()
	mock.calls.UpdateCodebase = nil
	mock.lockUpdateCodebase.Unlock()
}

// UpdateCodebaseByProjectIdAndVersionTag calls UpdateCodebaseByProjectIdAndVersionTagFunc.
func (mock *DataStoreQueriesStub) UpdateCodebaseByProjectIdAndVersionTag(ctx context.Context, arg persister.UpdateCodebaseByProjectIdAndVersionTagParams) error {
	if mock.UpdateCodebaseByProjectIdAndVersionTagFunc == nil {
		panic("DataStoreQueriesStub.UpdateCodebaseByProjectIdAndVersionTagFunc: method is nil but DataStoreQueries.UpdateCodebaseByProjectIdAndVersionTag was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpdateCodebaseByProjectIdAndVersionTagParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdateCodebaseByProjectIdAndVersionTag.Lock()
	mock.calls.UpdateCodebaseByProjectIdAndVersionTag = append(mock.calls.UpdateCodebaseByProjectIdAndVersionTag, callInfo)
	mock.lockUpdateCodebaseByProjectIdAndVersionTag.Unlock()
	return mock.UpdateCodebaseByProjectIdAndVersionTagFunc(ctx, arg)
}

// UpdateCodebaseByProjectIdAndVersionTagCalls gets all the calls that were made to UpdateCodebaseByProjectIdAndVersionTag.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpdateCodebaseByProjectIdAndVersionTagCalls())
func (mock *DataStoreQueriesStub) UpdateCodebaseByProjectIdAndVersionTagCalls() []struct {
	Ctx context.Context
	Arg persister.UpdateCodebaseByProjectIdAndVersionTagParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpdateCodebaseByProjectIdAndVersionTagParams
	}
	mock.lockUpdateCodebaseByProjectIdAndVersionTag.RLock()
	calls = mock.calls.UpdateCodebaseByProjectIdAndVersionTag
	mock.lockUpdateCodebaseByProjectIdAndVersionTag.RUnlock()
	return calls
}

// ResetUpdateCodebaseByProjectIdAndVersionTagCalls reset all the calls that were made to UpdateCodebaseByProjectIdAndVersionTag.
func (mock *DataStoreQueriesStub) ResetUpdateCodebaseByProjectIdAndVersionTagCalls() {
	mock.lockUpdateCodebaseByProjectIdAndVersionTag.Lock()
	mock.calls.UpdateCodebaseByProjectIdAndVersionTag = nil
	mock.lockUpdateCodebaseByProjectIdAndVersionTag.Unlock()
}

// UpdateFile calls UpdateFileFunc.
func (mock *DataStoreQueriesStub) UpdateFile(ctx context.Context, arg persister.UpdateFileParams) error {
	if mock.UpdateFileFunc == nil {
		panic("DataStoreQueriesStub.UpdateFileFunc: method is nil but DataStoreQueries.UpdateFile was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpdateFileParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdateFile.Lock()
	mock.calls.UpdateFile = append(mock.calls.UpdateFile, callInfo)
	mock.lockUpdateFile.Unlock()
	return mock.UpdateFileFunc(ctx, arg)
}

// UpdateFileCalls gets all the calls that were made to UpdateFile.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpdateFileCalls())
func (mock *DataStoreQueriesStub) UpdateFileCalls() []struct {
	Ctx context.Context
	Arg persister.UpdateFileParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpdateFileParams
	}
	mock.lockUpdateFile.RLock()
	calls = mock.calls.UpdateFile
	mock.lockUpdateFile.RUnlock()
	return calls
}

// ResetUpdateFileCalls reset all the calls that were made to UpdateFile.
func (mock *DataStoreQueriesStub) ResetUpdateFileCalls() {
	mock.lockUpdateFile.Lock()
	mock.calls.UpdateFile = nil
	mock.lockUpdateFile.Unlock()
}

// UpdateImport calls UpdateImportFunc.
func (mock *DataStoreQueriesStub) UpdateImport(ctx context.Context, arg persister.UpdateImportParams) error {
	if mock.UpdateImportFunc == nil {
		panic("DataStoreQueriesStub.UpdateImportFunc: method is nil but DataStoreQueries.UpdateImport was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpdateImportParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdateImport.Lock()
	mock.calls.UpdateImport = append(mock.calls.UpdateImport, callInfo)
	mock.lockUpdateImport.Unlock()
	return mock.UpdateImportFunc(ctx, arg)
}

// UpdateImportCalls gets all the calls that were made to UpdateImport.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpdateImportCalls())
func (mock *DataStoreQueriesStub) UpdateImportCalls() []struct {
	Ctx context.Context
	Arg persister.UpdateImportParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpdateImportParams
	}
	mock.lockUpdateImport.RLock()
	calls = mock.calls.UpdateImport
	mock.lockUpdateImport.RUnlock()
	return calls
}

// ResetUpdateImportCalls reset all the calls that were made to UpdateImport.
func (mock *DataStoreQueriesStub) ResetUpdateImportCalls() {
	mock.lockUpdateImport.Lock()
	mock.calls.UpdateImport = nil
	mock.lockUpdateImport.Unlock()
}

// UpdateMethod calls UpdateMethodFunc.
func (mock *DataStoreQueriesStub) UpdateMethod(ctx context.Context, arg persister.UpdateMethodParams) error {
	if mock.UpdateMethodFunc == nil {
		panic("DataStoreQueriesStub.UpdateMethodFunc: method is nil but DataStoreQueries.UpdateMethod was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpdateMethodParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdateMethod.Lock()
	mock.calls.UpdateMethod = append(mock.calls.UpdateMethod, callInfo)
	mock.lockUpdateMethod.Unlock()
	return mock.UpdateMethodFunc(ctx, arg)
}

// UpdateMethodCalls gets all the calls that were made to UpdateMethod.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpdateMethodCalls())
func (mock *DataStoreQueriesStub) UpdateMethodCalls() []struct {
	Ctx context.Context
	Arg persister.UpdateMethodParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpdateMethodParams
	}
	mock.lockUpdateMethod.RLock()
	calls = mock.calls.UpdateMethod
	mock.lockUpdateMethod.RUnlock()
	return calls
}

// ResetUpdateMethodCalls reset all the calls that were made to UpdateMethod.
func (mock *DataStoreQueriesStub) ResetUpdateMethodCalls() {
	mock.lockUpdateMethod.Lock()
	mock.calls.UpdateMethod = nil
	mock.lockUpdateMethod.Unlock()
}

// UpdateModule calls UpdateModuleFunc.
func (mock *DataStoreQueriesStub) UpdateModule(ctx context.Context, arg persister.UpdateModuleParams) error {
	if mock.UpdateModuleFunc == nil {
		panic("DataStoreQueriesStub.UpdateModuleFunc: method is nil but DataStoreQueries.UpdateModule was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpdateModuleParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdateModule.Lock()
	mock.calls.UpdateModule = append(mock.calls.UpdateModule, callInfo)
	mock.lockUpdateModule.Unlock()
	return mock.UpdateModuleFunc(ctx, arg)
}

// UpdateModuleCalls gets all the calls that were made to UpdateModule.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpdateModuleCalls())
func (mock *DataStoreQueriesStub) UpdateModuleCalls() []struct {
	Ctx context.Context
	Arg persister.UpdateModuleParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpdateModuleParams
	}
	mock.lockUpdateModule.RLock()
	calls = mock.calls.UpdateModule
	mock.lockUpdateModule.RUnlock()
	return calls
}

// ResetUpdateModuleCalls reset all the calls that were made to UpdateModule.
func (mock *DataStoreQueriesStub) ResetUpdateModuleCalls() {
	mock.lockUpdateModule.Lock()
	mock.calls.UpdateModule = nil
	mock.lockUpdateModule.Unlock()
}

// UpdateModuleVersion calls UpdateModuleVersionFunc.
func (mock *DataStoreQueriesStub) UpdateModuleVersion(ctx context.Context, arg persister.UpdateModuleVersionParams) error {
	if mock.UpdateModuleVersionFunc == nil {
		panic("DataStoreQueriesStub.UpdateModuleVersionFunc: method is nil but DataStoreQueries.UpdateModuleVersion was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpdateModuleVersionParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdateModuleVersion.Lock()
	mock.calls.UpdateModuleVersion = append(mock.calls.UpdateModuleVersion, callInfo)
	mock.lockUpdateModuleVersion.Unlock()
	return mock.UpdateModuleVersionFunc(ctx, arg)
}

// UpdateModuleVersionCalls gets all the calls that were made to UpdateModuleVersion.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpdateModuleVersionCalls())
func (mock *DataStoreQueriesStub) UpdateModuleVersionCalls() []struct {
	Ctx context.Context
	Arg persister.UpdateModuleVersionParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpdateModuleVersionParams
	}
	mock.lockUpdateModuleVersion.RLock()
	calls = mock.calls.UpdateModuleVersion
	mock.lockUpdateModuleVersion.RUnlock()
	return calls
}

// ResetUpdateModuleVersionCalls reset all the calls that were made to UpdateModuleVersion.
func (mock *DataStoreQueriesStub) ResetUpdateModuleVersionCalls() {
	mock.lockUpdateModuleVersion.Lock()
	mock.calls.UpdateModuleVersion = nil
	mock.lockUpdateModuleVersion.Unlock()
}

// UpdatePackage calls UpdatePackageFunc.
func (mock *DataStoreQueriesStub) UpdatePackage(ctx context.Context, arg persister.UpdatePackageParams) error {
	if mock.UpdatePackageFunc == nil {
		panic("DataStoreQueriesStub.UpdatePackageFunc: method is nil but DataStoreQueries.UpdatePackage was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpdatePackageParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdatePackage.Lock()
	mock.calls.UpdatePackage = append(mock.calls.UpdatePackage, callInfo)
	mock.lockUpdatePackage.Unlock()
	return mock.UpdatePackageFunc(ctx, arg)
}

// UpdatePackageCalls gets all the calls that were made to UpdatePackage.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpdatePackageCalls())
func (mock *DataStoreQueriesStub) UpdatePackageCalls() []struct {
	Ctx context.Context
	Arg persister.UpdatePackageParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpdatePackageParams
	}
	mock.lockUpdatePackage.RLock()
	calls = mock.calls.UpdatePackage
	mock.lockUpdatePackage.RUnlock()
	return calls
}

// ResetUpdatePackageCalls reset all the calls that were made to UpdatePackage.
func (mock *DataStoreQueriesStub) ResetUpdatePackageCalls() {
	mock.lockUpdatePackage.Lock()
	mock.calls.UpdatePackage = nil
	mock.lockUpdatePackage.Unlock()
}

// UpdatePackageType calls UpdatePackageTypeFunc.
func (mock *DataStoreQueriesStub) UpdatePackageType(ctx context.Context, arg persister.UpdatePackageTypeParams) error {
	if mock.UpdatePackageTypeFunc == nil {
		panic("DataStoreQueriesStub.UpdatePackageTypeFunc: method is nil but DataStoreQueries.UpdatePackageType was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpdatePackageTypeParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdatePackageType.Lock()
	mock.calls.UpdatePackageType = append(mock.calls.UpdatePackageType, callInfo)
	mock.lockUpdatePackageType.Unlock()
	return mock.UpdatePackageTypeFunc(ctx, arg)
}

// UpdatePackageTypeCalls gets all the calls that were made to UpdatePackageType.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpdatePackageTypeCalls())
func (mock *DataStoreQueriesStub) UpdatePackageTypeCalls() []struct {
	Ctx context.Context
	Arg persister.UpdatePackageTypeParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpdatePackageTypeParams
	}
	mock.lockUpdatePackageType.RLock()
	calls = mock.calls.UpdatePackageType
	mock.lockUpdatePackageType.RUnlock()
	return calls
}

// ResetUpdatePackageTypeCalls reset all the calls that were made to UpdatePackageType.
func (mock *DataStoreQueriesStub) ResetUpdatePackageTypeCalls() {
	mock.lockUpdatePackageType.Lock()
	mock.calls.UpdatePackageType = nil
	mock.lockUpdatePackageType.Unlock()
}

// UpdatePackageVersion calls UpdatePackageVersionFunc.
func (mock *DataStoreQueriesStub) UpdatePackageVersion(ctx context.Context, arg persister.UpdatePackageVersionParams) error {
	if mock.UpdatePackageVersionFunc == nil {
		panic("DataStoreQueriesStub.UpdatePackageVersionFunc: method is nil but DataStoreQueries.UpdatePackageVersion was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpdatePackageVersionParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdatePackageVersion.Lock()
	mock.calls.UpdatePackageVersion = append(mock.calls.UpdatePackageVersion, callInfo)
	mock.lockUpdatePackageVersion.Unlock()
	return mock.UpdatePackageVersionFunc(ctx, arg)
}

// UpdatePackageVersionCalls gets all the calls that were made to UpdatePackageVersion.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpdatePackageVersionCalls())
func (mock *DataStoreQueriesStub) UpdatePackageVersionCalls() []struct {
	Ctx context.Context
	Arg persister.UpdatePackageVersionParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpdatePackageVersionParams
	}
	mock.lockUpdatePackageVersion.RLock()
	calls = mock.calls.UpdatePackageVersion
	mock.lockUpdatePackageVersion.RUnlock()
	return calls
}

// ResetUpdatePackageVersionCalls reset all the calls that were made to UpdatePackageVersion.
func (mock *DataStoreQueriesStub) ResetUpdatePackageVersionCalls() {
	mock.lockUpdatePackageVersion.Lock()
	mock.calls.UpdatePackageVersion = nil
	mock.lockUpdatePackageVersion.Unlock()
}

// UpdateProject calls UpdateProjectFunc.
func (mock *DataStoreQueriesStub) UpdateProject(ctx context.Context, arg persister.UpdateProjectParams) error {
	if mock.UpdateProjectFunc == nil {
		panic("DataStoreQueriesStub.UpdateProjectFunc: method is nil but DataStoreQueries.UpdateProject was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpdateProjectParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdateProject.Lock()
	mock.calls.UpdateProject = append(mock.calls.UpdateProject, callInfo)
	mock.lockUpdateProject.Unlock()
	return mock.UpdateProjectFunc(ctx, arg)
}

// UpdateProjectCalls gets all the calls that were made to UpdateProject.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpdateProjectCalls())
func (mock *DataStoreQueriesStub) UpdateProjectCalls() []struct {
	Ctx context.Context
	Arg persister.UpdateProjectParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpdateProjectParams
	}
	mock.lockUpdateProject.RLock()
	calls = mock.calls.UpdateProject
	mock.lockUpdateProject.RUnlock()
	return calls
}

// ResetUpdateProjectCalls reset all the calls that were made to UpdateProject.
func (mock *DataStoreQueriesStub) ResetUpdateProjectCalls() {
	mock.lockUpdateProject.Lock()
	mock.calls.UpdateProject = nil
	mock.lockUpdateProject.Unlock()
}

// UpdateProjectByName calls UpdateProjectByNameFunc.
func (mock *DataStoreQueriesStub) UpdateProjectByName(ctx context.Context, arg persister.UpdateProjectByNameParams) error {
	if mock.UpdateProjectByNameFunc == nil {
		panic("DataStoreQueriesStub.UpdateProjectByNameFunc: method is nil but DataStoreQueries.UpdateProjectByName was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpdateProjectByNameParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdateProjectByName.Lock()
	mock.calls.UpdateProjectByName = append(mock.calls.UpdateProjectByName, callInfo)
	mock.lockUpdateProjectByName.Unlock()
	return mock.UpdateProjectByNameFunc(ctx, arg)
}

// UpdateProjectByNameCalls gets all the calls that were made to UpdateProjectByName.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpdateProjectByNameCalls())
func (mock *DataStoreQueriesStub) UpdateProjectByNameCalls() []struct {
	Ctx context.Context
	Arg persister.UpdateProjectByNameParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpdateProjectByNameParams
	}
	mock.lockUpdateProjectByName.RLock()
	calls = mock.calls.UpdateProjectByName
	mock.lockUpdateProjectByName.RUnlock()
	return calls
}

// ResetUpdateProjectByNameCalls reset all the calls that were made to UpdateProjectByName.
func (mock *DataStoreQueriesStub) ResetUpdateProjectByNameCalls() {
	mock.lockUpdateProjectByName.Lock()
	mock.calls.UpdateProjectByName = nil
	mock.lockUpdateProjectByName.Unlock()
}

// UpdateSurveyModule calls UpdateSurveyModuleFunc.
func (mock *DataStoreQueriesStub) UpdateSurveyModule(ctx context.Context, arg persister.UpdateSurveyModuleParams) error {
	if mock.UpdateSurveyModuleFunc == nil {
		panic("DataStoreQueriesStub.UpdateSurveyModuleFunc: method is nil but DataStoreQueries.UpdateSurveyModule was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpdateSurveyModuleParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdateSurveyModule.Lock()
	mock.calls.UpdateSurveyModule = append(mock.calls.UpdateSurveyModule, callInfo)
	mock.lockUpdateSurveyModule.Unlock()
	return mock.UpdateSurveyModuleFunc(ctx, arg)
}

// UpdateSurveyModuleCalls gets all the calls that were made to UpdateSurveyModule.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpdateSurveyModuleCalls())
func (mock *DataStoreQueriesStub) UpdateSurveyModuleCalls() []struct {
	Ctx context.Context
	Arg persister.UpdateSurveyModuleParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpdateSurveyModuleParams
	}
	mock.lockUpdateSurveyModule.RLock()
	calls = mock.calls.UpdateSurveyModule
	mock.lockUpdateSurveyModule.RUnlock()
	return calls
}

// ResetUpdateSurveyModuleCalls reset all the calls that were made to UpdateSurveyModule.
func (mock *DataStoreQueriesStub) ResetUpdateSurveyModuleCalls() {
	mock.lockUpdateSurveyModule.Lock()
	mock.calls.UpdateSurveyModule = nil
	mock.lockUpdateSurveyModule.Unlock()
}

// UpdateSymbolType calls UpdateSymbolTypeFunc.
func (mock *DataStoreQueriesStub) UpdateSymbolType(ctx context.Context, arg persister.UpdateSymbolTypeParams) error {
	if mock.UpdateSymbolTypeFunc == nil {
		panic("DataStoreQueriesStub.UpdateSymbolTypeFunc: method is nil but DataStoreQueries.UpdateSymbolType was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpdateSymbolTypeParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdateSymbolType.Lock()
	mock.calls.UpdateSymbolType = append(mock.calls.UpdateSymbolType, callInfo)
	mock.lockUpdateSymbolType.Unlock()
	return mock.UpdateSymbolTypeFunc(ctx, arg)
}

// UpdateSymbolTypeCalls gets all the calls that were made to UpdateSymbolType.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpdateSymbolTypeCalls())
func (mock *DataStoreQueriesStub) UpdateSymbolTypeCalls() []struct {
	Ctx context.Context
	Arg persister.UpdateSymbolTypeParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpdateSymbolTypeParams
	}
	mock.lockUpdateSymbolType.RLock()
	calls = mock.calls.UpdateSymbolType
	mock.lockUpdateSymbolType.RUnlock()
	return calls
}

// ResetUpdateSymbolTypeCalls reset all the calls that were made to UpdateSymbolType.
func (mock *DataStoreQueriesStub) ResetUpdateSymbolTypeCalls() {
	mock.lockUpdateSymbolType.Lock()
	mock.calls.UpdateSymbolType = nil
	mock.lockUpdateSymbolType.Unlock()
}

// UpdateType calls UpdateTypeFunc.
func (mock *DataStoreQueriesStub) UpdateType(ctx context.Context, arg persister.UpdateTypeParams) error {
	if mock.UpdateTypeFunc == nil {
		panic("DataStoreQueriesStub.UpdateTypeFunc: method is nil but DataStoreQueries.UpdateType was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpdateTypeParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdateType.Lock()
	mock.calls.UpdateType = append(mock.calls.UpdateType, callInfo)
	mock.lockUpdateType.Unlock()
	return mock.UpdateTypeFunc(ctx, arg)
}

// UpdateTypeCalls gets all the calls that were made to UpdateType.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpdateTypeCalls())
func (mock *DataStoreQueriesStub) UpdateTypeCalls() []struct {
	Ctx context.Context
	Arg persister.UpdateTypeParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpdateTypeParams
	}
	mock.lockUpdateType.RLock()
	calls = mock.calls.UpdateType
	mock.lockUpdateType.RUnlock()
	return calls
}

// ResetUpdateTypeCalls reset all the calls that were made to UpdateType.
func (mock *DataStoreQueriesStub) ResetUpdateTypeCalls() {
	mock.lockUpdateType.Lock()
	mock.calls.UpdateType = nil
	mock.lockUpdateType.Unlock()
}

// UpdateVariable calls UpdateVariableFunc.
func (mock *DataStoreQueriesStub) UpdateVariable(ctx context.Context, arg persister.UpdateVariableParams) error {
	if mock.UpdateVariableFunc == nil {
		panic("DataStoreQueriesStub.UpdateVariableFunc: method is nil but DataStoreQueries.UpdateVariable was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpdateVariableParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdateVariable.Lock()
	mock.calls.UpdateVariable = append(mock.calls.UpdateVariable, callInfo)
	mock.lockUpdateVariable.Unlock()
	return mock.UpdateVariableFunc(ctx, arg)
}

// UpdateVariableCalls gets all the calls that were made to UpdateVariable.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpdateVariableCalls())
func (mock *DataStoreQueriesStub) UpdateVariableCalls() []struct {
	Ctx context.Context
	Arg persister.UpdateVariableParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpdateVariableParams
	}
	mock.lockUpdateVariable.RLock()
	calls = mock.calls.UpdateVariable
	mock.lockUpdateVariable.RUnlock()
	return calls
}

// ResetUpdateVariableCalls reset all the calls that were made to UpdateVariable.
func (mock *DataStoreQueriesStub) ResetUpdateVariableCalls() {
	mock.lockUpdateVariable.Lock()
	mock.calls.UpdateVariable = nil
	mock.lockUpdateVariable.Unlock()
}

// UpsertCategory calls UpsertCategoryFunc.
func (mock *DataStoreQueriesStub) UpsertCategory(ctx context.Context, arg persister.UpsertCategoryParams) (persister.Category, error) {
	if mock.UpsertCategoryFunc == nil {
		panic("DataStoreQueriesStub.UpsertCategoryFunc: method is nil but DataStoreQueries.UpsertCategory was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpsertCategoryParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpsertCategory.Lock()
	mock.calls.UpsertCategory = append(mock.calls.UpsertCategory, callInfo)
	mock.lockUpsertCategory.Unlock()
	return mock.UpsertCategoryFunc(ctx, arg)
}

// UpsertCategoryCalls gets all the calls that were made to UpsertCategory.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpsertCategoryCalls())
func (mock *DataStoreQueriesStub) UpsertCategoryCalls() []struct {
	Ctx context.Context
	Arg persister.UpsertCategoryParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpsertCategoryParams
	}
	mock.lockUpsertCategory.RLock()
	calls = mock.calls.UpsertCategory
	mock.lockUpsertCategory.RUnlock()
	return calls
}

// ResetUpsertCategoryCalls reset all the calls that were made to UpsertCategory.
func (mock *DataStoreQueriesStub) ResetUpsertCategoryCalls() {
	mock.lockUpsertCategory.Lock()
	mock.calls.UpsertCategory = nil
	mock.lockUpsertCategory.Unlock()
}

// UpsertCodebase calls UpsertCodebaseFunc.
func (mock *DataStoreQueriesStub) UpsertCodebase(ctx context.Context, arg persister.UpsertCodebaseParams) (persister.Codebase, error) {
	if mock.UpsertCodebaseFunc == nil {
		panic("DataStoreQueriesStub.UpsertCodebaseFunc: method is nil but DataStoreQueries.UpsertCodebase was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpsertCodebaseParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpsertCodebase.Lock()
	mock.calls.UpsertCodebase = append(mock.calls.UpsertCodebase, callInfo)
	mock.lockUpsertCodebase.Unlock()
	return mock.UpsertCodebaseFunc(ctx, arg)
}

// UpsertCodebaseCalls gets all the calls that were made to UpsertCodebase.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpsertCodebaseCalls())
func (mock *DataStoreQueriesStub) UpsertCodebaseCalls() []struct {
	Ctx context.Context
	Arg persister.UpsertCodebaseParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpsertCodebaseParams
	}
	mock.lockUpsertCodebase.RLock()
	calls = mock.calls.UpsertCodebase
	mock.lockUpsertCodebase.RUnlock()
	return calls
}

// ResetUpsertCodebaseCalls reset all the calls that were made to UpsertCodebase.
func (mock *DataStoreQueriesStub) ResetUpsertCodebaseCalls() {
	mock.lockUpsertCodebase.Lock()
	mock.calls.UpsertCodebase = nil
	mock.lockUpsertCodebase.Unlock()
}

// UpsertFile calls UpsertFileFunc.
func (mock *DataStoreQueriesStub) UpsertFile(ctx context.Context, arg persister.UpsertFileParams) (persister.File, error) {
	if mock.UpsertFileFunc == nil {
		panic("DataStoreQueriesStub.UpsertFileFunc: method is nil but DataStoreQueries.UpsertFile was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpsertFileParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpsertFile.Lock()
	mock.calls.UpsertFile = append(mock.calls.UpsertFile, callInfo)
	mock.lockUpsertFile.Unlock()
	return mock.UpsertFileFunc(ctx, arg)
}

// UpsertFileCalls gets all the calls that were made to UpsertFile.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpsertFileCalls())
func (mock *DataStoreQueriesStub) UpsertFileCalls() []struct {
	Ctx context.Context
	Arg persister.UpsertFileParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpsertFileParams
	}
	mock.lockUpsertFile.RLock()
	calls = mock.calls.UpsertFile
	mock.lockUpsertFile.RUnlock()
	return calls
}

// ResetUpsertFileCalls reset all the calls that were made to UpsertFile.
func (mock *DataStoreQueriesStub) ResetUpsertFileCalls() {
	mock.lockUpsertFile.Lock()
	mock.calls.UpsertFile = nil
	mock.lockUpsertFile.Unlock()
}

// UpsertImport calls UpsertImportFunc.
func (mock *DataStoreQueriesStub) UpsertImport(ctx context.Context, arg persister.UpsertImportParams) (persister.Import, error) {
	if mock.UpsertImportFunc == nil {
		panic("DataStoreQueriesStub.UpsertImportFunc: method is nil but DataStoreQueries.UpsertImport was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpsertImportParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpsertImport.Lock()
	mock.calls.UpsertImport = append(mock.calls.UpsertImport, callInfo)
	mock.lockUpsertImport.Unlock()
	return mock.UpsertImportFunc(ctx, arg)
}

// UpsertImportCalls gets all the calls that were made to UpsertImport.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpsertImportCalls())
func (mock *DataStoreQueriesStub) UpsertImportCalls() []struct {
	Ctx context.Context
	Arg persister.UpsertImportParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpsertImportParams
	}
	mock.lockUpsertImport.RLock()
	calls = mock.calls.UpsertImport
	mock.lockUpsertImport.RUnlock()
	return calls
}

// ResetUpsertImportCalls reset all the calls that were made to UpsertImport.
func (mock *DataStoreQueriesStub) ResetUpsertImportCalls() {
	mock.lockUpsertImport.Lock()
	mock.calls.UpsertImport = nil
	mock.lockUpsertImport.Unlock()
}

// UpsertModule calls UpsertModuleFunc.
func (mock *DataStoreQueriesStub) UpsertModule(ctx context.Context, name string) (persister.Module, error) {
	if mock.UpsertModuleFunc == nil {
		panic("DataStoreQueriesStub.UpsertModuleFunc: method is nil but DataStoreQueries.UpsertModule was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockUpsertModule.Lock()
	mock.calls.UpsertModule = append(mock.calls.UpsertModule, callInfo)
	mock.lockUpsertModule.Unlock()
	return mock.UpsertModuleFunc(ctx, name)
}

// UpsertModuleCalls gets all the calls that were made to UpsertModule.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpsertModuleCalls())
func (mock *DataStoreQueriesStub) UpsertModuleCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockUpsertModule.RLock()
	calls = mock.calls.UpsertModule
	mock.lockUpsertModule.RUnlock()
	return calls
}

// ResetUpsertModuleCalls reset all the calls that were made to UpsertModule.
func (mock *DataStoreQueriesStub) ResetUpsertModuleCalls() {
	mock.lockUpsertModule.Lock()
	mock.calls.UpsertModule = nil
	mock.lockUpsertModule.Unlock()
}

// UpsertModuleVersion calls UpsertModuleVersionFunc.
func (mock *DataStoreQueriesStub) UpsertModuleVersion(ctx context.Context, arg persister.UpsertModuleVersionParams) (persister.ModuleVersion, error) {
	if mock.UpsertModuleVersionFunc == nil {
		panic("DataStoreQueriesStub.UpsertModuleVersionFunc: method is nil but DataStoreQueries.UpsertModuleVersion was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpsertModuleVersionParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpsertModuleVersion.Lock()
	mock.calls.UpsertModuleVersion = append(mock.calls.UpsertModuleVersion, callInfo)
	mock.lockUpsertModuleVersion.Unlock()
	return mock.UpsertModuleVersionFunc(ctx, arg)
}

// UpsertModuleVersionCalls gets all the calls that were made to UpsertModuleVersion.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpsertModuleVersionCalls())
func (mock *DataStoreQueriesStub) UpsertModuleVersionCalls() []struct {
	Ctx context.Context
	Arg persister.UpsertModuleVersionParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpsertModuleVersionParams
	}
	mock.lockUpsertModuleVersion.RLock()
	calls = mock.calls.UpsertModuleVersion
	mock.lockUpsertModuleVersion.RUnlock()
	return calls
}

// ResetUpsertModuleVersionCalls reset all the calls that were made to UpsertModuleVersion.
func (mock *DataStoreQueriesStub) ResetUpsertModuleVersionCalls() {
	mock.lockUpsertModuleVersion.Lock()
	mock.calls.UpsertModuleVersion = nil
	mock.lockUpsertModuleVersion.Unlock()
}

// UpsertPackage calls UpsertPackageFunc.
func (mock *DataStoreQueriesStub) UpsertPackage(ctx context.Context, arg persister.UpsertPackageParams) (persister.Package, error) {
	if mock.UpsertPackageFunc == nil {
		panic("DataStoreQueriesStub.UpsertPackageFunc: method is nil but DataStoreQueries.UpsertPackage was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpsertPackageParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpsertPackage.Lock()
	mock.calls.UpsertPackage = append(mock.calls.UpsertPackage, callInfo)
	mock.lockUpsertPackage.Unlock()
	return mock.UpsertPackageFunc(ctx, arg)
}

// UpsertPackageCalls gets all the calls that were made to UpsertPackage.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpsertPackageCalls())
func (mock *DataStoreQueriesStub) UpsertPackageCalls() []struct {
	Ctx context.Context
	Arg persister.UpsertPackageParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpsertPackageParams
	}
	mock.lockUpsertPackage.RLock()
	calls = mock.calls.UpsertPackage
	mock.lockUpsertPackage.RUnlock()
	return calls
}

// ResetUpsertPackageCalls reset all the calls that were made to UpsertPackage.
func (mock *DataStoreQueriesStub) ResetUpsertPackageCalls() {
	mock.lockUpsertPackage.Lock()
	mock.calls.UpsertPackage = nil
	mock.lockUpsertPackage.Unlock()
}

// UpsertPackageType calls UpsertPackageTypeFunc.
func (mock *DataStoreQueriesStub) UpsertPackageType(ctx context.Context, arg persister.UpsertPackageTypeParams) (persister.PackageType, error) {
	if mock.UpsertPackageTypeFunc == nil {
		panic("DataStoreQueriesStub.UpsertPackageTypeFunc: method is nil but DataStoreQueries.UpsertPackageType was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpsertPackageTypeParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpsertPackageType.Lock()
	mock.calls.UpsertPackageType = append(mock.calls.UpsertPackageType, callInfo)
	mock.lockUpsertPackageType.Unlock()
	return mock.UpsertPackageTypeFunc(ctx, arg)
}

// UpsertPackageTypeCalls gets all the calls that were made to UpsertPackageType.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpsertPackageTypeCalls())
func (mock *DataStoreQueriesStub) UpsertPackageTypeCalls() []struct {
	Ctx context.Context
	Arg persister.UpsertPackageTypeParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpsertPackageTypeParams
	}
	mock.lockUpsertPackageType.RLock()
	calls = mock.calls.UpsertPackageType
	mock.lockUpsertPackageType.RUnlock()
	return calls
}

// ResetUpsertPackageTypeCalls reset all the calls that were made to UpsertPackageType.
func (mock *DataStoreQueriesStub) ResetUpsertPackageTypeCalls() {
	mock.lockUpsertPackageType.Lock()
	mock.calls.UpsertPackageType = nil
	mock.lockUpsertPackageType.Unlock()
}

// UpsertPackageVersion calls UpsertPackageVersionFunc.
func (mock *DataStoreQueriesStub) UpsertPackageVersion(ctx context.Context, arg persister.UpsertPackageVersionParams) (persister.PackageVersion, error) {
	if mock.UpsertPackageVersionFunc == nil {
		panic("DataStoreQueriesStub.UpsertPackageVersionFunc: method is nil but DataStoreQueries.UpsertPackageVersion was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpsertPackageVersionParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpsertPackageVersion.Lock()
	mock.calls.UpsertPackageVersion = append(mock.calls.UpsertPackageVersion, callInfo)
	mock.lockUpsertPackageVersion.Unlock()
	return mock.UpsertPackageVersionFunc(ctx, arg)
}

// UpsertPackageVersionCalls gets all the calls that were made to UpsertPackageVersion.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpsertPackageVersionCalls())
func (mock *DataStoreQueriesStub) UpsertPackageVersionCalls() []struct {
	Ctx context.Context
	Arg persister.UpsertPackageVersionParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpsertPackageVersionParams
	}
	mock.lockUpsertPackageVersion.RLock()
	calls = mock.calls.UpsertPackageVersion
	mock.lockUpsertPackageVersion.RUnlock()
	return calls
}

// ResetUpsertPackageVersionCalls reset all the calls that were made to UpsertPackageVersion.
func (mock *DataStoreQueriesStub) ResetUpsertPackageVersionCalls() {
	mock.lockUpsertPackageVersion.Lock()
	mock.calls.UpsertPackageVersion = nil
	mock.lockUpsertPackageVersion.Unlock()
}

// UpsertProject calls UpsertProjectFunc.
func (mock *DataStoreQueriesStub) UpsertProject(ctx context.Context, arg persister.UpsertProjectParams) (persister.Project, error) {
	if mock.UpsertProjectFunc == nil {
		panic("DataStoreQueriesStub.UpsertProjectFunc: method is nil but DataStoreQueries.UpsertProject was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpsertProjectParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpsertProject.Lock()
	mock.calls.UpsertProject = append(mock.calls.UpsertProject, callInfo)
	mock.lockUpsertProject.Unlock()
	return mock.UpsertProjectFunc(ctx, arg)
}

// UpsertProjectCalls gets all the calls that were made to UpsertProject.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpsertProjectCalls())
func (mock *DataStoreQueriesStub) UpsertProjectCalls() []struct {
	Ctx context.Context
	Arg persister.UpsertProjectParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpsertProjectParams
	}
	mock.lockUpsertProject.RLock()
	calls = mock.calls.UpsertProject
	mock.lockUpsertProject.RUnlock()
	return calls
}

// ResetUpsertProjectCalls reset all the calls that were made to UpsertProject.
func (mock *DataStoreQueriesStub) ResetUpsertProjectCalls() {
	mock.lockUpsertProject.Lock()
	mock.calls.UpsertProject = nil
	mock.lockUpsertProject.Unlock()
}

// UpsertSurveyModule calls UpsertSurveyModuleFunc.
func (mock *DataStoreQueriesStub) UpsertSurveyModule(ctx context.Context, arg persister.UpsertSurveyModuleParams) (persister.SurveyModule, error) {
	if mock.UpsertSurveyModuleFunc == nil {
		panic("DataStoreQueriesStub.UpsertSurveyModuleFunc: method is nil but DataStoreQueries.UpsertSurveyModule was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpsertSurveyModuleParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpsertSurveyModule.Lock()
	mock.calls.UpsertSurveyModule = append(mock.calls.UpsertSurveyModule, callInfo)
	mock.lockUpsertSurveyModule.Unlock()
	return mock.UpsertSurveyModuleFunc(ctx, arg)
}

// UpsertSurveyModuleCalls gets all the calls that were made to UpsertSurveyModule.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpsertSurveyModuleCalls())
func (mock *DataStoreQueriesStub) UpsertSurveyModuleCalls() []struct {
	Ctx context.Context
	Arg persister.UpsertSurveyModuleParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpsertSurveyModuleParams
	}
	mock.lockUpsertSurveyModule.RLock()
	calls = mock.calls.UpsertSurveyModule
	mock.lockUpsertSurveyModule.RUnlock()
	return calls
}

// ResetUpsertSurveyModuleCalls reset all the calls that were made to UpsertSurveyModule.
func (mock *DataStoreQueriesStub) ResetUpsertSurveyModuleCalls() {
	mock.lockUpsertSurveyModule.Lock()
	mock.calls.UpsertSurveyModule = nil
	mock.lockUpsertSurveyModule.Unlock()
}

// UpsertSymbolType calls UpsertSymbolTypeFunc.
func (mock *DataStoreQueriesStub) UpsertSymbolType(ctx context.Context, arg persister.UpsertSymbolTypeParams) (persister.SymbolType, error) {
	if mock.UpsertSymbolTypeFunc == nil {
		panic("DataStoreQueriesStub.UpsertSymbolTypeFunc: method is nil but DataStoreQueries.UpsertSymbolType was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg persister.UpsertSymbolTypeParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpsertSymbolType.Lock()
	mock.calls.UpsertSymbolType = append(mock.calls.UpsertSymbolType, callInfo)
	mock.lockUpsertSymbolType.Unlock()
	return mock.UpsertSymbolTypeFunc(ctx, arg)
}

// UpsertSymbolTypeCalls gets all the calls that were made to UpsertSymbolType.
// Check the length with:
//
//	len(mockedDataStoreQueries.UpsertSymbolTypeCalls())
func (mock *DataStoreQueriesStub) UpsertSymbolTypeCalls() []struct {
	Ctx context.Context
	Arg persister.UpsertSymbolTypeParams
} {
	var calls []struct {
		Ctx context.Context
		Arg persister.UpsertSymbolTypeParams
	}
	mock.lockUpsertSymbolType.RLock()
	calls = mock.calls.UpsertSymbolType
	mock.lockUpsertSymbolType.RUnlock()
	return calls
}

// ResetUpsertSymbolTypeCalls reset all the calls that were made to UpsertSymbolType.
func (mock *DataStoreQueriesStub) ResetUpsertSymbolTypeCalls() {
	mock.lockUpsertSymbolType.Lock()
	mock.calls.UpsertSymbolType = nil
	mock.lockUpsertSymbolType.Unlock()
}

// WithTx calls WithTxFunc.
func (mock *DataStoreQueriesStub) WithTx(tx *sql.Tx) *persister.Queries {
	if mock.WithTxFunc == nil {
		panic("DataStoreQueriesStub.WithTxFunc: method is nil but DataStoreQueries.WithTx was just called")
	}
	callInfo := struct {
		Tx *sql.Tx
	}{
		Tx: tx,
	}
	mock.lockWithTx.Lock()
	mock.calls.WithTx = append(mock.calls.WithTx, callInfo)
	mock.lockWithTx.Unlock()
	return mock.WithTxFunc(tx)
}

// WithTxCalls gets all the calls that were made to WithTx.
// Check the length with:
//
//	len(mockedDataStoreQueries.WithTxCalls())
func (mock *DataStoreQueriesStub) WithTxCalls() []struct {
	Tx *sql.Tx
} {
	var calls []struct {
		Tx *sql.Tx
	}
	mock.lockWithTx.RLock()
	calls = mock.calls.WithTx
	mock.lockWithTx.RUnlock()
	return calls
}

// ResetWithTxCalls reset all the calls that were made to WithTx.
func (mock *DataStoreQueriesStub) ResetWithTxCalls() {
	mock.lockWithTx.Lock()
	mock.calls.WithTx = nil
	mock.lockWithTx.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *DataStoreQueriesStub) ResetCalls() {
	mock.lockDeleteCategory.Lock()
	mock.calls.DeleteCategory = nil
	mock.lockDeleteCategory.Unlock()

	mock.lockDeleteCodebase.Lock()
	mock.calls.DeleteCodebase = nil
	mock.lockDeleteCodebase.Unlock()

	mock.lockDeleteCodebaseByProjectIdAndVersionTag.Lock()
	mock.calls.DeleteCodebaseByProjectIdAndVersionTag = nil
	mock.lockDeleteCodebaseByProjectIdAndVersionTag.Unlock()

	mock.lockDeleteCodebaseSurveys.Lock()
	mock.calls.DeleteCodebaseSurveys = nil
	mock.lockDeleteCodebaseSurveys.Unlock()

	mock.lockDeleteFile.Lock()
	mock.calls.DeleteFile = nil
	mock.lockDeleteFile.Unlock()

	mock.lockDeleteImport.Lock()
	mock.calls.DeleteImport = nil
	mock.lockDeleteImport.Unlock()

	mock.lockDeleteMethod.Lock()
	mock.calls.DeleteMethod = nil
	mock.lockDeleteMethod.Unlock()

	mock.lockDeleteModule.Lock()
	mock.calls.DeleteModule = nil
	mock.lockDeleteModule.Unlock()

	mock.lockDeleteModuleVersion.Lock()
	mock.calls.DeleteModuleVersion = nil
	mock.lockDeleteModuleVersion.Unlock()

	mock.lockDeletePackage.Lock()
	mock.calls.DeletePackage = nil
	mock.lockDeletePackage.Unlock()

	mock.lockDeletePackageType.Lock()
	mock.calls.DeletePackageType = nil
	mock.lockDeletePackageType.Unlock()

	mock.lockDeletePackageVersion.Lock()
	mock.calls.DeletePackageVersion = nil
	mock.lockDeletePackageVersion.Unlock()

	mock.lockDeleteProject.Lock()
	mock.calls.DeleteProject = nil
	mock.lockDeleteProject.Unlock()

	mock.lockDeleteProjectByName.Lock()
	mock.calls.DeleteProjectByName = nil
	mock.lockDeleteProjectByName.Unlock()

	mock.lockDeleteSurvey.Lock()
	mock.calls.DeleteSurvey = nil
	mock.lockDeleteSurvey.Unlock()

	mock.lockDeleteSurveyModule.Lock()
	mock.calls.DeleteSurveyModule = nil
	mock.lockDeleteSurveyModule.Unlock()

	mock.lockDeleteSymbolType.Lock()
	mock.calls.DeleteSymbolType = nil
	mock.lockDeleteSymbolType.Unlock()

	mock.lockDeleteType.Lock()
	mock.calls.DeleteType = nil
	mock.lockDeleteType.Unlock()

	mock.lockDeleteVariable.Lock()
	mock.calls.DeleteVariable = nil
	mock.lockDeleteVariable.Unlock()

	mock.lockInsertCategory.Lock()
	mock.calls.InsertCategory = nil
	mock.lockInsertCategory.Unlock()

	mock.lockInsertCodebase.Lock()
	mock.calls.InsertCodebase = nil
	mock.lockInsertCodebase.Unlock()

	mock.lockInsertFile.Lock()
	mock.calls.InsertFile = nil
	mock.lockInsertFile.Unlock()

	mock.lockInsertImport.Lock()
	mock.calls.InsertImport = nil
	mock.lockInsertImport.Unlock()

	mock.lockInsertMethod.Lock()
	mock.calls.InsertMethod = nil
	mock.lockInsertMethod.Unlock()

	mock.lockInsertModule.Lock()
	mock.calls.InsertModule = nil
	mock.lockInsertModule.Unlock()

	mock.lockInsertModuleVersion.Lock()
	mock.calls.InsertModuleVersion = nil
	mock.lockInsertModuleVersion.Unlock()

	mock.lockInsertPackage.Lock()
	mock.calls.InsertPackage = nil
	mock.lockInsertPackage.Unlock()

	mock.lockInsertPackageType.Lock()
	mock.calls.InsertPackageType = nil
	mock.lockInsertPackageType.Unlock()

	mock.lockInsertPackageVersion.Lock()
	mock.calls.InsertPackageVersion = nil
	mock.lockInsertPackageVersion.Unlock()

	mock.lockInsertProject.Lock()
	mock.calls.InsertProject = nil
	mock.lockInsertProject.Unlock()

	mock.lockInsertSurvey.Lock()
	mock.calls.InsertSurvey = nil
	mock.lockInsertSurvey.Unlock()

	mock.lockInsertSurveyModule.Lock()
	mock.calls.InsertSurveyModule = nil
	mock.lockInsertSurveyModule.Unlock()

	mock.lockInsertSymbolType.Lock()
	mock.calls.InsertSymbolType = nil
	mock.lockInsertSymbolType.Unlock()

	mock.lockInsertType.Lock()
	mock.calls.InsertType = nil
	mock.lockInsertType.Unlock()

	mock.lockInsertVariable.Lock()
	mock.calls.InsertVariable = nil
	mock.lockInsertVariable.Unlock()

	mock.lockListCategories.Lock()
	mock.calls.ListCategories = nil
	mock.lockListCategories.Unlock()

	mock.lockListCodebaseSurveys.Lock()
	mock.calls.ListCodebaseSurveys = nil
	mock.lockListCodebaseSurveys.Unlock()

	mock.lockListCodebases.Lock()
	mock.calls.ListCodebases = nil
	mock.lockListCodebases.Unlock()

	mock.lockListFiles.Lock()
	mock.calls.ListFiles = nil
	mock.lockListFiles.Unlock()

	mock.lockListFilesBySurvey.Lock()
	mock.calls.ListFilesBySurvey = nil
	mock.lockListFilesBySurvey.Unlock()

	mock.lockListImports.Lock()
	mock.calls.ListImports = nil
	mock.lockListImports.Unlock()

	mock.lockListMethods.Lock()
	mock.calls.ListMethods = nil
	mock.lockListMethods.Unlock()

	mock.lockListModuleVersions.Lock()
	mock.calls.ListModuleVersions = nil
	mock.lockListModuleVersions.Unlock()

	mock.lockListModules.Lock()
	mock.calls.ListModules = nil
	mock.lockListModules.Unlock()

	mock.lockListPackageTypes.Lock()
	mock.calls.ListPackageTypes = nil
	mock.lockListPackageTypes.Unlock()

	mock.lockListPackageTypesByName.Lock()
	mock.calls.ListPackageTypesByName = nil
	mock.lockListPackageTypesByName.Unlock()

	mock.lockListPackageVersions.Lock()
	mock.calls.ListPackageVersions = nil
	mock.lockListPackageVersions.Unlock()

	mock.lockListPackages.Lock()
	mock.calls.ListPackages = nil
	mock.lockListPackages.Unlock()

	mock.lockListProjects.Lock()
	mock.calls.ListProjects = nil
	mock.lockListProjects.Unlock()

	mock.lockListSurveyModules.Lock()
	mock.calls.ListSurveyModules = nil
	mock.lockListSurveyModules.Unlock()

	mock.lockListSurveys.Lock()
	mock.calls.ListSurveys = nil
	mock.lockListSurveys.Unlock()

	mock.lockListSymbolTypes.Lock()
	mock.calls.ListSymbolTypes = nil
	mock.lockListSymbolTypes.Unlock()

	mock.lockListSymbolTypesByName.Lock()
	mock.calls.ListSymbolTypesByName = nil
	mock.lockListSymbolTypesByName.Unlock()

	mock.lockListTypes.Lock()
	mock.calls.ListTypes = nil
	mock.lockListTypes.Unlock()

	mock.lockListTypesByFile.Lock()
	mock.calls.ListTypesByFile = nil
	mock.lockListTypesByFile.Unlock()

	mock.lockListTypesBySurvey.Lock()
	mock.calls.ListTypesBySurvey = nil
	mock.lockListTypesBySurvey.Unlock()

	mock.lockListVariables.Lock()
	mock.calls.ListVariables = nil
	mock.lockListVariables.Unlock()

	mock.lockLoadCategory.Lock()
	mock.calls.LoadCategory = nil
	mock.lockLoadCategory.Unlock()

	mock.lockLoadCodebase.Lock()
	mock.calls.LoadCodebase = nil
	mock.lockLoadCodebase.Unlock()

	mock.lockLoadCodebaseIDByProjectAndVersion.Lock()
	mock.calls.LoadCodebaseIDByProjectAndVersion = nil
	mock.lockLoadCodebaseIDByProjectAndVersion.Unlock()

	mock.lockLoadCodebaseIdByRepoURL.Lock()
	mock.calls.LoadCodebaseIdByRepoURL = nil
	mock.lockLoadCodebaseIdByRepoURL.Unlock()

	mock.lockLoadFile.Lock()
	mock.calls.LoadFile = nil
	mock.lockLoadFile.Unlock()

	mock.lockLoadImport.Lock()
	mock.calls.LoadImport = nil
	mock.lockLoadImport.Unlock()

	mock.lockLoadMethod.Lock()
	mock.calls.LoadMethod = nil
	mock.lockLoadMethod.Unlock()

	mock.lockLoadModule.Lock()
	mock.calls.LoadModule = nil
	mock.lockLoadModule.Unlock()

	mock.lockLoadModuleVersion.Lock()
	mock.calls.LoadModuleVersion = nil
	mock.lockLoadModuleVersion.Unlock()

	mock.lockLoadPackage.Lock()
	mock.calls.LoadPackage = nil
	mock.lockLoadPackage.Unlock()

	mock.lockLoadPackageType.Lock()
	mock.calls.LoadPackageType = nil
	mock.lockLoadPackageType.Unlock()

	mock.lockLoadPackageVersion.Lock()
	mock.calls.LoadPackageVersion = nil
	mock.lockLoadPackageVersion.Unlock()

	mock.lockLoadProject.Lock()
	mock.calls.LoadProject = nil
	mock.lockLoadProject.Unlock()

	mock.lockLoadProjectByName.Lock()
	mock.calls.LoadProjectByName = nil
	mock.lockLoadProjectByName.Unlock()

	mock.lockLoadProjectByRepoURL.Lock()
	mock.calls.LoadProjectByRepoURL = nil
	mock.lockLoadProjectByRepoURL.Unlock()

	mock.lockLoadProjectRepoURL.Lock()
	mock.calls.LoadProjectRepoURL = nil
	mock.lockLoadProjectRepoURL.Unlock()

	mock.lockLoadSurvey.Lock()
	mock.calls.LoadSurvey = nil
	mock.lockLoadSurvey.Unlock()

	mock.lockLoadSurveyByRepoURL.Lock()
	mock.calls.LoadSurveyByRepoURL = nil
	mock.lockLoadSurveyByRepoURL.Unlock()

	mock.lockLoadSurveyModule.Lock()
	mock.calls.LoadSurveyModule = nil
	mock.lockLoadSurveyModule.Unlock()

	mock.lockLoadSymbolType.Lock()
	mock.calls.LoadSymbolType = nil
	mock.lockLoadSymbolType.Unlock()

	mock.lockLoadType.Lock()
	mock.calls.LoadType = nil
	mock.lockLoadType.Unlock()

	mock.lockLoadVariable.Lock()
	mock.calls.LoadVariable = nil
	mock.lockLoadVariable.Unlock()

	mock.lockUpdateCategory.Lock()
	mock.calls.UpdateCategory = nil
	mock.lockUpdateCategory.Unlock()

	mock.lockUpdateCodebase.Lock()
	mock.calls.UpdateCodebase = nil
	mock.lockUpdateCodebase.Unlock()

	mock.lockUpdateCodebaseByProjectIdAndVersionTag.Lock()
	mock.calls.UpdateCodebaseByProjectIdAndVersionTag = nil
	mock.lockUpdateCodebaseByProjectIdAndVersionTag.Unlock()

	mock.lockUpdateFile.Lock()
	mock.calls.UpdateFile = nil
	mock.lockUpdateFile.Unlock()

	mock.lockUpdateImport.Lock()
	mock.calls.UpdateImport = nil
	mock.lockUpdateImport.Unlock()

	mock.lockUpdateMethod.Lock()
	mock.calls.UpdateMethod = nil
	mock.lockUpdateMethod.Unlock()

	mock.lockUpdateModule.Lock()
	mock.calls.UpdateModule = nil
	mock.lockUpdateModule.Unlock()

	mock.lockUpdateModuleVersion.Lock()
	mock.calls.UpdateModuleVersion = nil
	mock.lockUpdateModuleVersion.Unlock()

	mock.lockUpdatePackage.Lock()
	mock.calls.UpdatePackage = nil
	mock.lockUpdatePackage.Unlock()

	mock.lockUpdatePackageType.Lock()
	mock.calls.UpdatePackageType = nil
	mock.lockUpdatePackageType.Unlock()

	mock.lockUpdatePackageVersion.Lock()
	mock.calls.UpdatePackageVersion = nil
	mock.lockUpdatePackageVersion.Unlock()

	mock.lockUpdateProject.Lock()
	mock.calls.UpdateProject = nil
	mock.lockUpdateProject.Unlock()

	mock.lockUpdateProjectByName.Lock()
	mock.calls.UpdateProjectByName = nil
	mock.lockUpdateProjectByName.Unlock()

	mock.lockUpdateSurveyModule.Lock()
	mock.calls.UpdateSurveyModule = nil
	mock.lockUpdateSurveyModule.Unlock()

	mock.lockUpdateSymbolType.Lock()
	mock.calls.UpdateSymbolType = nil
	mock.lockUpdateSymbolType.Unlock()

	mock.lockUpdateType.Lock()
	mock.calls.UpdateType = nil
	mock.lockUpdateType.Unlock()

	mock.lockUpdateVariable.Lock()
	mock.calls.UpdateVariable = nil
	mock.lockUpdateVariable.Unlock()

	mock.lockUpsertCategory.Lock()
	mock.calls.UpsertCategory = nil
	mock.lockUpsertCategory.Unlock()

	mock.lockUpsertCodebase.Lock()
	mock.calls.UpsertCodebase = nil
	mock.lockUpsertCodebase.Unlock()

	mock.lockUpsertFile.Lock()
	mock.calls.UpsertFile = nil
	mock.lockUpsertFile.Unlock()

	mock.lockUpsertImport.Lock()
	mock.calls.UpsertImport = nil
	mock.lockUpsertImport.Unlock()

	mock.lockUpsertModule.Lock()
	mock.calls.UpsertModule = nil
	mock.lockUpsertModule.Unlock()

	mock.lockUpsertModuleVersion.Lock()
	mock.calls.UpsertModuleVersion = nil
	mock.lockUpsertModuleVersion.Unlock()

	mock.lockUpsertPackage.Lock()
	mock.calls.UpsertPackage = nil
	mock.lockUpsertPackage.Unlock()

	mock.lockUpsertPackageType.Lock()
	mock.calls.UpsertPackageType = nil
	mock.lockUpsertPackageType.Unlock()

	mock.lockUpsertPackageVersion.Lock()
	mock.calls.UpsertPackageVersion = nil
	mock.lockUpsertPackageVersion.Unlock()

	mock.lockUpsertProject.Lock()
	mock.calls.UpsertProject = nil
	mock.lockUpsertProject.Unlock()

	mock.lockUpsertSurveyModule.Lock()
	mock.calls.UpsertSurveyModule = nil
	mock.lockUpsertSurveyModule.Unlock()

	mock.lockUpsertSymbolType.Lock()
	mock.calls.UpsertSymbolType = nil
	mock.lockUpsertSymbolType.Unlock()

	mock.lockWithTx.Lock()
	mock.calls.WithTx = nil
	mock.lockWithTx.Unlock()
}
